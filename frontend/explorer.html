<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Hashcash Explorer</title>
  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, sans-serif; }
    body { margin: 0; background: #0b0f17; color: #e6edf3; }
    header { position: sticky; top: 0; z-index: 10; background: #0b0f17; border-bottom: 1px solid #1f2a44; }
    .wrap { max-width: 1100px; margin: 0 auto; padding: 14px 16px; }
    h1 { font-size: 18px; margin: 0 0 10px; font-weight: 700; }
    .controls { display: flex; flex-wrap: wrap; gap: 10px; align-items: center; }
    input, select, button {
      background: #0f172a; color: #e6edf3; border: 1px solid #263455; border-radius: 10px;
      padding: 10px 12px; font-size: 14px;
    }
    input { min-width: 280px; }
    button { cursor: pointer; }
    button:hover { border-color: #3b82f6; }
    .pill { font-size: 12px; padding: 6px 10px; border-radius: 999px; border: 1px solid #263455; background: #0f172a; }
    .status { display: flex; flex-wrap: wrap; gap: 8px; margin-top: 10px; }
    .err { color: #ff9a9a; }
    table { width: 100%; border-collapse: collapse; }
    th, td { padding: 10px 8px; border-bottom: 1px solid #1f2a44; vertical-align: top; }
    th { text-align: left; font-size: 12px; letter-spacing: .03em; color: #a8b3cf; text-transform: uppercase; }
    td { font-size: 13px; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    .muted { color: #9aa4bd; }
    .type { font-weight: 700; }
    .amount-pos { color: #7ee787; }
    .amount-neg { color: #ff7b72; }
    .meta { white-space: pre-wrap; word-break: break-word; }
    .spinner {
      width: 12px;
      height: 12px;
      border: 2px solid #263455;
      border-top-color: #3b82f6;
      border-radius: 50%;
      display: inline-block;
      vertical-align: -2px;
      animation: spin 0.8s linear infinite;
      margin-right: 6px;
    }
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
  </style>
</head>
<body>
<header>
  <div class="wrap">
    <h1>Hashcash Explorer</h1>

    <div class="controls">
      <input id="accountId" class="mono" placeholder="HCC address or txid" />

      <button id="refreshBtn">Search</button>
      <button id="firstBtn" title="Back to newest (first page)">⏮ First</button>
      <button id="prevBtn" title="Previous page">◀ Prev</button>
      <button id="nextBtn" title="Next page">Next ▶</button>
      <!-- Auto/interval controls removed -->

      <button id="shareBtn" title="Copy link">Copy Link</button>
      <button id="clearBtn" title="Clear filter">Clear</button>
    </div>

    <div class="status">
      <span class="pill" id="countPill">0 events</span>
      <span class="pill" id="lastPill">last: —</span>
      <span class="pill" id="pagePill">page 1</span>
      <span class="pill muted" id="cdPill" style="display:none;">refresh in 30s</span>
      <span class="pill" id="loadingPill" style="display:none;"><span class="spinner"></span>Searching…</span>
      <span class="pill" id="balPill" style="display:none;">Balance: — HCC</span>
      <span class="pill" id="lockPill" style="display:none;">Locked: — HCC</span>
      <span class="pill muted" id="hintPill">...</span>
      <span class="pill err" id="errPill" style="display:none;"></span>
    </div>
  </div>
</header>

<main class="wrap">
  <table>
    <thead>
      <tr>
        <th style="width:140px;">Time</th>
        <th style="width:140px;">Tx</th>
        <th style="width:120px;">Type</th>
        <th style="width:90px;">Amount</th>
        <th>Account</th>
        <th style="width:80px;">Other</th>
        <th style="width:330px;">Meta</th>
      </tr>
    </thead>
    <tbody id="rows"></tbody>
  </table>
</main>

<script>
  const DEFAULT_API_BASE = "https://hashcash-pow-faucet.dynv6.net/api";
  const $ = (id) => document.getElementById(id);

  const PAGE_SIZE = 50;      // fixed page size (smaller = snappier UI)
  let currentPage = 0;

  // Cursor pagination
  let newestId = 0;
  let nextBeforeId = null;

  // For Prev navigation: store the cursor we used for each page.
  const pageCursors = [null]; // page 0 uses before_id=null

    // ----------------------------
  // Page caching + prefetch
  // ----------------------------
  const PAGE_CACHE_MAX = 16; // keep last N pages in memory
  const pageDataCache = new Map(); // key: pageIndex -> EventsPageOut
  const prefetchCache = new Map(); // key: beforeIdKey -> EventsPageOut (beforeIdKey is string)
  const inflightPrefetch = new Map(); // key -> Promise

  function beforeKey(beforeId) {
    return (beforeId && Number(beforeId) > 0) ? String(beforeId) : "newest";
  }

  function prunePageCache() {
    // keep most recent PAGE_CACHE_MAX entries around currentPage
    const keys = Array.from(pageDataCache.keys()).sort((a,b) => a-b);
    if (keys.length <= PAGE_CACHE_MAX) return;

    // prefer keeping a window around currentPage
    const keepMin = Math.max(0, currentPage - Math.floor(PAGE_CACHE_MAX / 2));
    const keepMax = keepMin + PAGE_CACHE_MAX - 1;

    for (const k of keys) {
      if (k < keepMin || k > keepMax) pageDataCache.delete(k);
      if (pageDataCache.size <= PAGE_CACHE_MAX) break;
    }

    // if still too big, drop oldest
    while (pageDataCache.size > PAGE_CACHE_MAX) {
      const kk = Math.min(...pageDataCache.keys());
      pageDataCache.delete(kk);
    }
  }

  async function prefetchByBeforeId(beforeId) {
    const key = beforeKey(beforeId);
    if (prefetchCache.has(key)) return;
    if (inflightPrefetch.has(key)) return;

    // Don't prefetch if user is already doing an interactive scan/search
    if (isBusy) return;

    const p = (async () => {
      try {
        const data = await fetchEventsPage(beforeId);
        prefetchCache.set(key, data);
      } catch {
        // ignore
      } finally {
        inflightPrefetch.delete(key);
      }
    })();

    inflightPrefetch.set(key, p);
  }

  async function prefetchNextTwoPages() {
    // Page 0: beforeId=null (newest). Next pages use next_before_id chain.
    // Strategy:
    // - prefetch nextBeforeId (page+1)
    // - if that prefetch returns quickly, also prefetch its next_before_id (page+2)
    if (!nextBeforeId) return;

    const first = nextBeforeId;
    await prefetchByBeforeId(first);

    // best-effort: if we already have the first prefetched, chain to second
    const k1 = beforeKey(first);
    const d1 = prefetchCache.get(k1);
    if (d1 && d1.next_before_id) {
      await prefetchByBeforeId(d1.next_before_id);
    }
  }

  function normalizeTxInput(s) {
    return (s || "").trim();
  }

  function looksLikeTxid(s) {
    const t = normalizeTxInput(s);
    // our computed txid is 16 hex chars (fnv1a64)
    return /^[0-9a-fA-F]{16}$/.test(t);
  }

  function looksLikeAccountId(s) {
    const t = (s || "").trim();
    return /^[0-9a-fA-F]{40}$/.test(t);
  }

  async function navigateToAccount(acc) {
    const a = (acc || "").trim();
    if (!a) return;
    // Stop any in-flight request and reset paging
    abortInflight();
    prefetchCache.clear();
    inflightPrefetch.clear();
    pageDataCache.clear();
    $("accountId").value = a;
    currentPage = 0;
    pageCursors.length = 0;
    pageCursors.push(null);
    updateUrlBar();
    await fetchEvents(null);
  }

  function fmtTime(ts) {
    if (!ts) return "—";
    const d = new Date(ts * 1000);
    return d.toLocaleString();
  }

  function amountClass(a) {
    if (a === null || a === undefined) return "";
    return (Number(a) >= 0) ? "amount-pos" : "amount-neg";
  }

  function safeString(x) {
    if (x === null || x === undefined) return "";
    if (typeof x === "string") return x;
    try { return JSON.stringify(x); } catch { return String(x); }
  }

  function toPrettyMeta(meta) {
    if (!meta) return "";
    try { return JSON.stringify(meta, null, 2); } catch { return safeString(meta); }
  }

  function stableEventKey(obj) {
    const keys = Object.keys(obj).sort();
    const parts = [];
    for (const k of keys) {
      let v = obj[k];
      if (v && typeof v === "object") {
        try {
          const mk = Object.keys(v).sort();
          const mv = {};
          for (const kk of mk) mv[kk] = v[kk];
          v = mv;
        } catch {}
      }
      parts.push(`${k}=${safeString(v)}`);
    }
    return parts.join("|");
  }

  function fnv1a64Hex(str) {
    let hash = 0xcbf29ce484222325n;
    const prime = 0x100000001b3n;
    for (let i = 0; i < str.length; i++) {
      hash ^= BigInt(str.charCodeAt(i));
      hash = (hash * prime) & 0xffffffffffffffffn;
    }
    return hash.toString(16).padStart(16, "0");
  }

  // TxID logic:
  // - Transfers are grouped by {ts, from, to, abs(amount)}.
  // - Redeem/burn-like events are grouped by meta.request_id if present.
  function computeTxId(e) {
    const type = e.type || "";
    const meta = (e.meta && typeof e.meta === "object") ? e.meta : {};
    const requestId = (meta.request_id ?? "").toString();

    // Group redeem-ish events by request_id if available
    if (requestId && (
        type.startsWith("redeem") ||
        type === "burn" ||
        type === "redeem_burn" ||
        type === "redeem_complete" ||
        type === "redeem_done"
    )) {
      return fnv1a64Hex(stableEventKey({ kind: "redeem", request_id: requestId }));
    }

    // Transfer grouping
    if (type === "transfer_out" || type === "transfer_in" || type === "transfer") {
      const amt = (e.amount === null || e.amount === undefined) ? 0 : Math.abs(Number(e.amount));
      const from = (type === "transfer_out" || type === "transfer") ? (e.account_id || "") : (e.other || "");
      const to = (type === "transfer_out" || type === "transfer") ? (e.other || "") : (e.account_id || "");
      const key = stableEventKey({ kind: "transfer", ts: e.ts || 0, from, to, amount: amt });
      return fnv1a64Hex(key);
    }

    // Default grouping: stable hash of key fields (+ request_id if present)
    const key = stableEventKey({
      kind: type,
      ts: e.ts || 0,
      account_id: e.account_id || "",
      other: e.other || "",
      amount: (e.amount === null || e.amount === undefined) ? "" : Number(e.amount),
      request_id: requestId,
      seq: meta.seq ?? "",
      bits: meta.bits ?? "",
      txid: meta.txid ?? "",
    });
    return fnv1a64Hex(key);
  }

  // Global view: merge transfer_in/out into TWO rows:
  //  - Sender row: amount negative, Other="sender"
  //  - Recipient row: amount positive, Other="recipient"
  // Account-filter view: keep raw events (so user sees exact in/out).
  function prepareDisplayEvents(events, hasAccountFilter) {
    const out = [];

    if (hasAccountFilter) {
      for (const e of events) out.push(Object.assign({}, e, { txid: computeTxId(e) }));
      return out;
    }

    const seenTransferTx = new Set();
    for (const e of events) {
      const type = e.type || "";
      const tx = computeTxId(e);

      if (type === "transfer_out" || type === "transfer_in") {
        if (seenTransferTx.has(tx)) continue;

        const amt = (e.amount === null || e.amount === undefined) ? 0 : Math.abs(Number(e.amount));
        const from = (type === "transfer_out") ? (e.account_id || "") : (e.other || "");
        const to = (type === "transfer_out") ? (e.other || "") : (e.account_id || "");

        // Row 1: sender
        out.push({
          id: e.id ?? null,
          ts: e.ts,
          type: "transfer",
          account_id: from,
          other: "sender",
          amount: -amt,
          meta: Object.assign({}, (e.meta || {}), { merged: true }),
          txid: tx,
        });

        // Row 2: recipient
        out.push({
          id: e.id ?? null,
          ts: e.ts,
          type: "transfer",
          account_id: to,
          other: "recipient",
          amount: amt,
          meta: null,
          txid: tx,
        });

        seenTransferTx.add(tx);
        continue;
      }

      out.push(Object.assign({}, e, { txid: tx }));
    }

    return out;
  }

  function buildUrl(beforeId) {
    const apiBase = (DEFAULT_API_BASE || "").replace(/\/+$/, "");
    const raw = $("accountId").value.trim();
    const isTx = looksLikeTxid(raw);
    const acc = isTx ? "" : raw;

    const u = new URL((apiBase || "") + "/events_page", window.location.origin);
    u.searchParams.set("limit", String(PAGE_SIZE));
    if (acc) u.searchParams.set("account_id", acc);
    if (beforeId && Number(beforeId) > 0) u.searchParams.set("before_id", String(beforeId));
    return u.toString();
  }

  function buildAccountUrl() {
    const apiBase = (DEFAULT_API_BASE || "").replace(/\/+$/, "");
    const raw = $("accountId").value.trim();
    const isTx = looksLikeTxid(raw);
    const acc = isTx ? "" : raw;
    const u = new URL((apiBase || "") + "/account", window.location.origin);
    if (acc) u.searchParams.set("account_id", acc);
    return u.toString();
  }

  let activeSearchToken = 0;
  let inflightController = null;
  let isBusy = false; // true while scanning txid or any fetch is in flight

  function abortInflight() {
    try {
      if (inflightController) inflightController.abort();
    } catch {}
    inflightController = null;
  }

  function setLoading(on, label) {
    const el = $("loadingPill");
    isBusy = !!on;
    if (!el) return;
    if (!on) {
      el.style.display = "none";
      el.lastChild && (el.lastChild.textContent = "Searching…");
      // When we stop loading, also abort any lingering in-flight request.
      abortInflight();
      return;
    }
    el.style.display = "inline-flex";
    // The pill contains: <span class="spinner"></span>TEXT
    // Update the text node after the spinner.
    if (typeof label === "string" && label) {
      // The second child is a text node in most browsers; fall back to setting innerHTML safely.
      try {
        el.childNodes[1].textContent = label;
      } catch {
        el.innerHTML = '<span class="spinner"></span>' + label;
      }
    }
  }

  function setErr(msg) {
    const el = $("errPill");
    if (!msg) { el.style.display = "none"; el.textContent = ""; return; }
    el.style.display = "inline-flex";
    el.textContent = msg;
  }

  function setBalancePills(credits, locked) {
    const bal = $("balPill");
    const lock = $("lockPill");
    if (credits === null || credits === undefined) {
      bal.style.display = "none";
      lock.style.display = "none";
      bal.textContent = "Balance: — HCC";
      lock.textContent = "Locked: — HCC";
      return;
    }
    bal.style.display = "inline-flex";
    lock.style.display = "inline-flex";
    bal.textContent = `Balance: ${credits} HCC`;
    lock.textContent = `Locked: ${locked ?? 0} HCC`;
  }

  async function fetchBalance() {
    const raw = $("accountId").value.trim();
    const isTx = looksLikeTxid(raw);
    const acc = isTx ? "" : raw;
    if (!acc) { setBalancePills(null, null); return; }
    try {
      const url = buildAccountUrl();
      const r = await fetch(url, { headers: { "accept": "application/json" }});
      if (!r.ok) { setBalancePills(null, null); return; }
      const data = await r.json();
      setBalancePills(data.credits ?? 0, data.locked_credits ?? 0);
    } catch { setBalancePills(null, null); }
  }

  function renderPage(data) {
    const tbody = $("rows");
    tbody.innerHTML = "";

    newestId = (data && typeof data.newest_id === "number") ? data.newest_id : 0;
    nextBeforeId = (data && (data.next_before_id !== undefined)) ? data.next_before_id : null;

    const events = (data && Array.isArray(data.events)) ? data.events : [];

    const raw = $("accountId").value.trim();
    const isTx = looksLikeTxid(raw);
    const hasAccountFilter = (!isTx) && raw.length > 0;
    const txFilter = isTx ? normalizeTxInput(raw) : "";

    let baseEvents = events;
    if (txFilter) {
      const needle = txFilter.toLowerCase();
      baseEvents = events.filter(ev => {
        try { return (computeTxId(ev) || "").toLowerCase() === needle; }
        catch { return false; }
      });
    }

    const displayEvents = prepareDisplayEvents(baseEvents, hasAccountFilter);

    $("pagePill").textContent = `page ${currentPage + 1}`;

    // Render newest-first within page
    let lastTxRendered = "";
    for (let i = displayEvents.length - 1; i >= 0; i--) {
      const e = displayEvents[i];
      const tr = document.createElement("tr");

      const curTx = (e.txid || "");
      const sameTxAsPrev = lastTxRendered && (lastTxRendered === curTx);
      if (!sameTxAsPrev) lastTxRendered = curTx;

      const tdTime = document.createElement("td");
      tdTime.textContent = sameTxAsPrev ? "" : fmtTime(e.ts);
      tdTime.className = "muted";
      tr.appendChild(tdTime);

      const tdTx = document.createElement("td");
      tdTx.className = "mono";
      const fullTx = e.txid || "";
      tdTx.textContent = sameTxAsPrev ? "" : fullTx;
      if (fullTx && !sameTxAsPrev) tdTx.title = fullTx;
      tr.appendChild(tdTx);

      const tdType = document.createElement("td");
      tdType.textContent = e.type || "";
      tdType.className = "type";
      tr.appendChild(tdType);

      const tdAmt = document.createElement("td");
      tdAmt.textContent = (e.amount === null || e.amount === undefined) ? "" : String(e.amount);
      tdAmt.className = amountClass(e.amount);
      tr.appendChild(tdAmt);

      const tdAcc = document.createElement("td");
      tdAcc.className = "mono";
      const accVal = (e.account_id || "").trim();
      if (accVal && looksLikeAccountId(accVal)) {
        const a = document.createElement("a");
        a.href = `${window.location.pathname}?account_id=${encodeURIComponent(accVal)}`;
        a.textContent = accVal;
        a.style.color = "#93c5fd";
        a.style.textDecoration = "none";
        a.addEventListener("mouseover", () => { a.style.textDecoration = "underline"; });
        a.addEventListener("mouseout", () => { a.style.textDecoration = "none"; });
        a.addEventListener("click", async (ev) => {
          ev.preventDefault();
          await navigateToAccount(accVal);
        });
        tdAcc.appendChild(a);
      } else {
        tdAcc.textContent = accVal;
      }
      tr.appendChild(tdAcc);

      const tdOther = document.createElement("td");
      tdOther.className = "mono";
      tdOther.style.maxWidth = "80px";
      tdOther.style.overflow = "hidden";
      tdOther.style.textOverflow = "ellipsis";
      tdOther.style.whiteSpace = "nowrap";

      const otherVal = (e.other || "").trim();
      if (otherVal && looksLikeAccountId(otherVal)) {
        const a2 = document.createElement("a");
        a2.href = `${window.location.pathname}?account_id=${encodeURIComponent(otherVal)}`;
        a2.textContent = otherVal;
        a2.title = otherVal;
        a2.style.color = "#93c5fd";
        a2.style.textDecoration = "none";
        a2.addEventListener("mouseover", () => { a2.style.textDecoration = "underline"; });
        a2.addEventListener("mouseout", () => { a2.style.textDecoration = "none"; });
        a2.addEventListener("click", async (ev) => {
          ev.preventDefault();
          await navigateToAccount(otherVal);
        });
        tdOther.appendChild(a2);
      } else {
        tdOther.textContent = otherVal;
        if (otherVal) tdOther.title = otherVal;
      }

      tr.appendChild(tdOther);

      const tdMeta = document.createElement("td");
      tdMeta.className = "meta mono";
      const metaStr = toPrettyMeta(e.meta);

      if (!metaStr) {
        tdMeta.textContent = "";
      } else {
        const btn = document.createElement("button");
        btn.type = "button";
        btn.textContent = "Show";
        btn.style.padding = "6px 10px";
        btn.style.borderRadius = "999px";
        btn.style.fontSize = "12px";
        btn.style.marginRight = "8px";

        const pre = document.createElement("pre");
        pre.className = "meta mono";
        pre.style.margin = "8px 0 0";
        pre.style.display = "none";
        pre.textContent = metaStr;

        btn.addEventListener("click", () => {
          const open = pre.style.display !== "none";
          pre.style.display = open ? "none" : "block";
          btn.textContent = open ? "Show" : "Hide";
        });

        tdMeta.appendChild(btn);
        tdMeta.appendChild(pre);
      }

      tr.appendChild(tdMeta);
      tbody.appendChild(tr);
    }

    $("countPill").textContent = `${displayEvents.length} events`;
    const newest = events.length ? fmtTime(events[events.length - 1].ts) : "—";
    $("lastPill").textContent = `last: ${newest}`;

    $("firstBtn").disabled = (currentPage <= 0);
    $("prevBtn").disabled = (currentPage <= 0);
    $("nextBtn").disabled = (!nextBeforeId);

    // Cache the rendered page for instant Prev/Back and reduce network jitter.
    try {
      pageDataCache.set(currentPage, data);
      prunePageCache();
    } catch {}

    // Kick off background prefetch for faster Next clicks (next 2 pages).
    // Fire-and-forget, but avoid piling up during interactive operations.
    prefetchNextTwoPages();
  }

  async function fetchEventsPage(beforeId = null) {
    // Prevent overlapping requests (e.g. fast clicking Next, or auto-refresh while paging).
    abortInflight();
    inflightController = new AbortController();

    const url = buildUrl(beforeId);
    const r = await fetch(url, {
      headers: { "accept": "application/json" },
      signal: inflightController.signal,
    });
    if (!r.ok) {
      const t = await r.text().catch(() => "");
      throw new Error(`HTTP ${r.status}: ${t || r.statusText}`);
    }
    const data = await r.json();
    return data;
  }

  async function fetchEvents(beforeId = null, forceNetwork = false) {
    setErr("");

    // Show spinner for normal paging/address searches.
    // (TXID scans handle their own spinner in the Search handler.)
    setLoading(true, "Loading…");

    // If this is a navigation fetch and we already have cached data for this page, render immediately.
    // IMPORTANT: auto-refresh must bypass cache, otherwise it will never show new events.
    if (!forceNetwork && beforeId === pageCursors[currentPage]) {
      const cached = pageDataCache.get(currentPage);
      if (cached) {
        try { await fetchBalance(); } catch {}
        renderPage(cached);
        setLoading(false);
        return;
      }
    }

    try {
      await fetchBalance();
      const data = await fetchEventsPage(beforeId);
      renderPage(data);
    } catch (e) {
      if (e && (e.name === "AbortError" || String(e).includes("AbortError"))) {
        // Silent: aborted due to a newer request.
        return;
      }
      setErr(e.message || String(e));
      renderPage({ newest_id: 0, next_before_id: null, events: [] });
    } finally {
      setLoading(false);
    }
  }

  function applyQueryParams() {
    const qs = new URLSearchParams(window.location.search);
    const acc = (qs.get("account_id") || "").trim();
    if (acc) $("accountId").value = acc;

    // Always start at newest page (cursor pagination can't restore old pages from URL)
    currentPage = 0;
    pageCursors.length = 0;
    pageCursors.push(null);
  }

  function updateUrlBar() {
    const qs = new URLSearchParams();
    const acc = $("accountId").value.trim();
    if (acc) qs.set("account_id", acc);

    const newUrl = `${window.location.pathname}?${qs.toString()}`;
    history.replaceState({}, "", newUrl);
  }

  $("refreshBtn").addEventListener("click", async () => {
    // Cancel any prior in-flight search
    const token = ++activeSearchToken;

    prefetchCache.clear();
    inflightPrefetch.clear();
    pageDataCache.clear();

    currentPage = 0;
    pageCursors.length = 0;
    pageCursors.push(null);
    updateUrlBar();

    const raw = $("accountId").value.trim();
    const isTx = looksLikeTxid(raw);

    if (!isTx) {
      await fetchEvents(null);
      return;
    }

    // TXID quick fix: scan up to 50 pages (PAGE_SIZE each) until we find a match.
    setErr("");
    setLoading(true, "Searching…");

    let beforeId = null;
    let found = false;

    try {
      for (let page = 0; page < 50; page++) {
        if (token !== activeSearchToken) return; // cancelled

        setLoading(true, `Searching… (${page + 1}/50)`);

        const data = await fetchEventsPage(beforeId);
        const events = (data && Array.isArray(data.events)) ? data.events : [];
        const needle = normalizeTxInput(raw).toLowerCase();

        // Does this page contain the txid?
        let pageHas = false;
        for (const ev of events) {
          try {
            const tx = (computeTxId(ev) || "").toLowerCase();
            if (tx === needle) { pageHas = true; break; }
          } catch {}
        }

        // Store cursor for this page so Prev works after we land here.
        pageCursors[page] = beforeId;

        if (pageHas) {
          currentPage = page;
          updateUrlBar();
          await fetchBalance();
          renderPage(data); // renderPage will filter to just this txid
          found = true;
          break;
        }

        // Advance cursor
        const nb = (data && (data.next_before_id !== undefined)) ? data.next_before_id : null;
        if (!nb) {
          // No more pages
          currentPage = page;
          updateUrlBar();
          await fetchBalance();
          renderPage(data);
          break;
        }
        beforeId = nb;
      }

      if (!found) {
        // If we scanned and didn't find, show a friendly message.
        setErr("txid not found in the last 50 pages");
      }
    } catch (e) {
      setErr(e.message || String(e));
      renderPage({ newest_id: 0, next_before_id: null, events: [] });
    } finally {
      if (token === activeSearchToken) setLoading(false);
    }
  });
  $("firstBtn").addEventListener("click", async () => {
    abortInflight();
    if (currentPage <= 0) return;

    currentPage = 0;
    pageCursors.length = 0;
    pageCursors.push(null);
    updateUrlBar();

    const cached = pageDataCache.get(0);
    if (cached) {
      try { await fetchBalance(); } catch {}
      renderPage(cached);
      return;
    }
    await fetchEvents(null);
  });
  $("prevBtn").addEventListener("click", async () => {
    abortInflight();
    if (currentPage <= 0) return;

    currentPage -= 1;
    updateUrlBar();

    const cached = pageDataCache.get(currentPage);
    if (cached) {
      try { await fetchBalance(); } catch {}
      renderPage(cached);
      return;
    }

    await fetchEvents(pageCursors[currentPage]);
  });
  $("nextBtn").addEventListener("click", async () => {
    abortInflight();
    if (!nextBeforeId) return;

    const targetBefore = nextBeforeId;

    currentPage += 1;
    pageCursors[currentPage] = targetBefore;
    updateUrlBar();

    // 1) If we already prefetched this page, render instantly.
    const k = beforeKey(targetBefore);
    const pref = prefetchCache.get(k);
    if (pref) {
      try { await fetchBalance(); } catch {}
      renderPage(pref);
      return;
    }

    // 2) Otherwise, fetch normally.
    await fetchEvents(targetBefore);
  });
  $("clearBtn").addEventListener("click", async () => {
    prefetchCache.clear();
    inflightPrefetch.clear();
    pageDataCache.clear();
    $("accountId").value = "";
    currentPage = 0;
    pageCursors.length = 0;
    pageCursors.push(null);
    updateUrlBar();
    setBalancePills(null, null);
    await fetchEvents(null);
  });
  $("accountId").addEventListener("change", () => {
    prefetchCache.clear();
    inflightPrefetch.clear();
    pageDataCache.clear();
    currentPage = 0;
    pageCursors.length = 0;
    pageCursors.push(null);
    updateUrlBar();
    fetchEvents(null);
  });

  $("shareBtn").addEventListener("click", async () => {
    updateUrlBar();
    const link = window.location.href;
    try {
      await navigator.clipboard.writeText(link);
      $("hintPill").textContent = "Link copied ✅";
      setTimeout(() => $("hintPill").textContent = "Tip: enter an HCC address or a txid and click Search. Auto refreshes every 30s.", 1200);
    } catch {
      prompt("Copy this link:", link);
    }
  });

  // ----------------------------
  // Boot: load data immediately
  // ----------------------------
  let didRenderOnce = false;
  const _origRenderPage = renderPage;
  renderPage = function(data) {
    didRenderOnce = true;
    return _origRenderPage(data);
  };

  async function bootNow() {
    // Ensure we start clean and show the first page right away.
    try {
      setErr("");
      setLoading(true, "Loading…");
      applyQueryParams();
      updateUrlBar();
      await fetchBalance();
      await fetchEvents(null);
    } catch {
      // ignore; auto-refresh/visibility handlers will retry
    } finally {
      setLoading(false);
      resetAutoCountdown();
    }

    // Safari/Firefox sometimes delay the first async fetch when the tab is just created.
    // If we still haven't rendered anything shortly after boot, retry once.
    setTimeout(() => {
      if (!didRenderOnce && document.visibilityState === "visible") {
        fetchEvents(null).catch(() => {});
      }
    }, 800);
  }

  // Run boot after the current call stack so all functions/handlers are registered.
  setTimeout(bootNow, 0);

  // Also retry on DOM ready / load for browsers with quirky scheduling.
  document.addEventListener("DOMContentLoaded", () => setTimeout(bootNow, 0), { once: true });
  window.addEventListener("load", () => setTimeout(bootNow, 0), { once: true });

  // Fixed auto refresh every 30 seconds (no UI control)
  // Notes:
  // - Browsers may throttle timers heavily in background tabs.
  // - When the tab becomes visible again, we force a refresh.
  const AUTO_REFRESH_MS = 30 * 1000;
  let lastAutoKick = 0;

  // Countdown UI for next refresh
  let nextAutoAtMs = Date.now() + AUTO_REFRESH_MS;

  function setCountdownVisible(on) {
    const el = $("cdPill");
    if (!el) return;
    el.style.display = on ? "inline-flex" : "none";
  }

  function updateCountdownLabel() {
    const el = $("cdPill");
    if (!el) return;

    // Only show countdown when it makes sense:
    // - on newest page
    // - tab visible
    // - not busy
    if (!canAutoRefresh()) {
      setCountdownVisible(false);
      return;
    }

    const now = Date.now();
    let left = Math.ceil((nextAutoAtMs - now) / 1000);
    if (!Number.isFinite(left)) left = 0;
    if (left < 0) left = 0;

    setCountdownVisible(true);
    el.textContent = `refresh in ${left}s`;
  }

  function resetAutoCountdown() {
    nextAutoAtMs = Date.now() + AUTO_REFRESH_MS;
    updateCountdownLabel();
  }

  function canAutoRefresh() {
    return document.visibilityState === "visible" && currentPage === 0 && !isBusy;
  }

  async function kickAutoRefresh(reason = "interval") {
    const now = Date.now();

    // Debounce: avoid double refreshes from focus+visibilitychange in quick succession.
    if (now - lastAutoKick < 1200) return;
    if (!canAutoRefresh()) return;

    // If a fetch is already in flight or we are scanning, do nothing.
    if (isBusy) return;

    lastAutoKick = now;

    // Schedule the NEXT refresh from *now* so the countdown matches reality,
    // even if browsers delay timers.
    nextAutoAtMs = now + AUTO_REFRESH_MS;
    updateCountdownLabel();

    try {
      await fetchEvents(null, true);
    } catch {
      // ignore
    }
  }

  setInterval(() => {
    updateCountdownLabel();

    // If the timer is due, refresh now. This avoids cases where the countdown hits 0
    // but the 30s interval hasn't fired (timer drift / browser scheduling).
    if (canAutoRefresh() && Date.now() >= nextAutoAtMs) {
      kickAutoRefresh("due");
    }
  }, 1000);

  // When returning to the tab, force a refresh (timers might have been throttled).
  document.addEventListener("visibilitychange", () => {
    if (document.visibilityState === "visible") {
      // Ensure we aren't stuck in a "busy" state due to a throttled/paused fetch.
      abortInflight();
      setLoading(false);
      resetAutoCountdown();
      kickAutoRefresh("visible");
    }
  });

  // Also refresh on window focus (some browsers don't fire visibilitychange reliably).
  window.addEventListener("focus", () => {
    abortInflight();
    setLoading(false);
    resetAutoCountdown();
    kickAutoRefresh("focus");
  });

</script>
</body>
</html>