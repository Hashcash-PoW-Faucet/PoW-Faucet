<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <script>
  // Early, crash-proof flag: allows CSS to switch to mobile UI for returning users
  (function () {
    try {
      var has = !!localStorage.getItem("account_id");
      document.documentElement.dataset.hasAccount = has ? "1" : "0";
    } catch (e) {
      document.documentElement.dataset.hasAccount = "0";
    }
  })();
</script>
  <link rel="stylesheet" href="styles.css">
  <!-- PWA -->
  <link rel="manifest" href="./manifest.webmanifest">
  <meta name="theme-color" content="#111827">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <link rel="apple-touch-icon" href="./icons/icon-192.png">
  <title>Hashcash PoW Faucet</title>
</head>
<body>
  <h1>
    <img src="AB.png" alt="Pixel portrait of Adam Back" class="ab-avatar">
    Hashcash PoW Faucet
  </h1>
<!-- Mobile-only: sticky mini top bar + quick navigation (shown only when logged in) -->
<div id="mobile-topbar" class="mobile-only">
  <div class="topbar-row">
    <div class="topbar-left">
      <div class="topbar-balance" id="mobile-balance">Balance: ‚Äì</div>
      <div class="topbar-earned" id="mobile-earned">Earned today: ‚Äì</div>
      <div class="topbar-addr">
        <span id="mobile-address">Address: ‚Äì</span>
        <button id="btn-mobile-copy" type="button" class="icon-button" title="Copy address">üìã</button>
        <button id="btn-mobile-show-qr" type="button" class="icon-button" title="Show address QR">üî≥</button>
      </div>
    </div>
    <div class="topbar-actions">
      <button id="btn-mobile-gear" type="button" class="icon-button" title="Menu">‚öôÔ∏è</button>
    </div>
  </div>

  <div id="mobile-menu" style="display:none;">
    <div style="display:flex; gap:10px; flex-wrap:wrap; align-items:center;">
      <a href="#account-section">Account</a>
      <a href="#dex-section">DEX</a>
      <a href="#about">About</a>
    </div>
  </div>
</div>

<div id="mobile-quick-actions" class="mobile-only">
  <div class="qa-row">
    <button id="btn-mobile-go-earn" type="button">Mine / Earn</button>
    <button id="btn-mobile-go-send" type="button">Send</button>
    <button id="btn-mobile-go-redeem" type="button">Redeem</button>
  </div>
</div>

  <!-- QR Modal (Show address / any text as QR) -->
<div id="qr-modal" class="modal-overlay" style="display:none;">
  <div class="modal-card" role="dialog" aria-modal="true" aria-labelledby="qr-modal-title">
    <div class="modal-header">
      <div id="qr-modal-title" class="modal-title">QR</div>
      <button id="btn-qr-close" type="button" class="icon-button" aria-label="Close">‚úñ</button>
    </div>
    <div id="qr-modal-body" style="text-align:center;">
      <div id="qr-box" style="display:none; margin: 0 auto; width:260px; height:260px; border-radius: 10px; background: rgba(255,255,255,0.08);"></div>
      <canvas id="qr-canvas" style="max-width: 260px; width: 100%; height: auto; border-radius: 10px; background: rgba(255,255,255,0.08);"></canvas>
      <div id="qr-render-hint" class="section-status" style="margin-top:10px; display:none;"></div>
      <div id="qr-modal-text" class="dex-mono" style="margin-top:10px; word-break: break-all; opacity:0.9;"></div>
      <div style="display:flex; gap:10px; justify-content:center; margin-top:12px;">
        <button id="btn-qr-copy" type="button">Copy</button>
      </div>
    </div>
  </div>
</div>

<!-- QR Scanner Modal (Scan QR into an input) -->
<div id="qr-scan-modal" class="modal-overlay" style="display:none;">
  <div class="modal-card" role="dialog" aria-modal="true" aria-labelledby="qr-scan-title">
    <div class="modal-header">
      <div id="qr-scan-title" class="modal-title">Scan QR</div>
      <button id="btn-qr-scan-close" type="button" class="icon-button" aria-label="Close">‚úñ</button>
    </div>
    <div id="qr-scan-body">
      <video id="qr-video" playsinline autoplay muted style="width:100%; border-radius: 12px; background: rgba(0,0,0,0.3);"></video>
      <div id="qr-scan-status" class="section-status" style="margin-top:10px;"></div>
      <div style="display:flex; gap:10px; justify-content:center; margin-top:10px;">
        <button id="btn-qr-scan-stop" type="button">Stop</button>
      </div>
    </div>
  </div>
</div>

<div id="info-section">
  <p>
    Create an anonymous account and earn <strong>Hash Cash Credits (HCC)</strong> by completing Proof-of-Work tasks.
    HCC can be sent to other accounts instantly and without fees.
  </p>
  <p>
    You can <strong>redeem</strong> by burning HCC for small tips in cryptocurrencies.
    A <strong>P2P DEX</strong> also lets you trade HCC for VECO, a low-fee crypto currency.
  </p>
  <p>
    <strong>Redeem</strong> is available for the following crypto currencies:
  </p>
  <div id="supported-coins">
    <p>Loading supported coins‚Ä¶</p>
  </div>

  <p id="info-account-required-note" style="margin-top:10px; opacity:0.85;">
    To use <strong>Redeem</strong> and <strong>DEX</strong>, you first need to mine an account once by solving a small Proof-of-Work puzzle.
    Depending on your hardware, this can take several minutes.
  </p>

  <p class="about-link"><a href="#about">You find more info here</a>. For updates, new features, and free HCC join our <a href="https://discord.gg/53w4DqaMqe" target="_blank" rel="noopener noreferrer">Discord Server</a>.</p>
</div>

  <div id="signup-section">
    <div class="button-row">
      <button id="btn-signup">Signup (PoW)</button>
      <button id="btn-stop-mining-signup" type="button" style="display:none;">Cancel</button>
    </div>
    <div id="signup-status" class="section-status" style="margin-top:10px;"></div>
    <div id="signup-hashrate" style="margin-top:8px; opacity:0.9; display:none;"></div>
    <div id="account-info"></div>

    <!-- If the final signup submit fails (network/proxy), allow retry without re-mining -->
    <button id="btn-signup-retry" type="button" style="display:none; margin-top:8px;">Retry signup submit</button>
    <div id="signup-retry-hint" class="section-status" style="margin-top:6px;"></div>
  </div>

  <div id="desktop-status-block">
  <hr>

  <div id="status-panel">
    <div id="status-address" style="display:none;"></div>
    <div id="credits"></div>
  </div>

  <hr>
</div>

  <div id="earn-section">
  <h2>Mining</h2>
    <div class="toggle-row">
      <button id="btn-toggle-mining-note" type="button" class="toggle-link" data-toggle-target="mining-note" data-toggle-label-show="Show info" data-toggle-label-hide="Hide">Show info</button>
      <div id="mining-note" class="toggle-content" style="display:none;">
        <p>
          Please note: You can mine into the same account from several devices on your home network in parallel, but not into different accounts.
          For optimal performance, especially on older and/or slow devices, we recommend using the <a href="https://github.com/Hashcash-PoW-Faucet/faucet-cpu-miner" target="_blank" rel="noopener noreferrer">CLI miner</a>.
        </p>
      </div>
    </div>

    <div id="status"></div>
    <div id="hashrate"></div>
    <div id="cooldown-countdown"></div>

    <div style="margin-top:6px;">
      <label>
        <input type="checkbox" id="auto-mine-checkbox">
        Auto-mine until daily cap (pauses during cooldown)
      </label>
    </div>

    <div style="margin-top:6px;">
      <label for="pow-threads">
        Worker threads:
        <input id="pow-threads" type="number" min="1" step="1" value="1" style="width:60px;">
        <span id="pow-threads-hint" style="font-size:12px; opacity:0.8;"></span>
      </label>
    </div>

    <div class="button-row">
      <button id="btn-earn">Earn 1 credit (PoW)</button>
      <button id="btn-stop-mining" type="button" style="display:none;">Stop mining</button>
    </div>

  </div>

  <hr>

  <div id="redeem-section">
    <h2>Redeem</h2>
    <div class="toggle-row">
      <button id="btn-toggle-redeem-note" type="button" class="toggle-link" data-toggle-target="redeem-note" data-toggle-label-show="Show info" data-toggle-label-hide="Hide">Show info</button>
      <div id="redeem-note" class="toggle-content" style="display:none;">
        <p>
          To request a redeem, you must own at least
          <span id="min-redeem-credits">20</span> HCC. Each redeem temporarily locks a fixed number of HCC from your balance. If a tip is sent, those locked HCC are burned; if no payout happens (for example because the faucet wallet is empty), the locked HCC are unlocked again.
        </p>
      </div>
    </div>
    <label for="redeem-address">Tip address:</label>

    <div class="header-row" style="gap:10px; align-items:center;">
      <input id="redeem-address" type="text" size="60" placeholder="Paste your crypto wallet address here" style="flex:1;">
      <button id="btn-scan-redeem" type="button" title="Scan QR">Scan QR</button>
    </div>

    <label for="redeem-currency">Currency:</label>
    <select id="redeem-currency">
      <option value="GRS">GRS</option>
      <option value="SLM">SLM</option>
      <option value="VECO">VECO</option>
    </select>
    <button id="btn-redeem">Request redeem</button>
    <div id="redeem-status" class="section-status" style="margin-top:10px;"></div>

    <div class="toggle-row" style="margin-top: 18px;">
    <button id="btn-toggle-redeem-log" type="button" class="toggle-link"
          data-toggle-target="redeem-log-wrap"
          data-toggle-label-show="Show redeem log"
          data-toggle-label-hide="Hide redeem log"
          data-default-open="desktop">Show redeem log</button>

    <div id="redeem-log-wrap" class="toggle-content" style="display:none;">
      <div class="header-row" style="margin:8px 0;">
        <small style="opacity:0.8;">Shows the last 10 redeem requests.</small>
        <button id="btn-clear-redeem-log" type="button">Refresh</button>
      </div>

      <div id="redeem-log" style="
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace;
        font-size: 12px;
        line-height: 1.35;
        white-space: pre-wrap;
        border: 1px solid rgba(255,255,255,0.15);
        border-radius: 8px;
        padding: 10px;
        background: rgba(0,0,0,0.25);
        max-height: 180px;
        overflow: auto;
      ">No redeems yet.</div>
    </div>
    </div>
  </div>

  <hr>

  <div id="send-section">
    <h2>Send HCC</h2>
    <p>Send HCC to another address.</p>
    <label for="send-to-address">Recipient address:</label>
    <div class="header-row" style="gap:10px; align-items:center;">
      <input id="send-to-address" type="text" size="60" placeholder="Paste recipient address here" style="flex:1;">
      <button id="btn-scan-send" type="button" title="Scan QR">Scan QR</button>
    </div>
    <p></p>
    <label for="send-amount">Amount:</label>
    <input id="send-amount" type="number" min="1" step="1" value="1">
    <button id="btn-send">Send HCC</button>
    <div id="send-status" class="section-status" style="margin-top:10px;"></div>
  </div>

  <hr>

    <div id="account-section">
    <h2>Account management</h2>
    <p><strong>Warning:</strong> Your private key controls all your HCC. Keep it safe and back it up.</p>
    <div id="address-info"></div>
    <label for="import-account">Import private key:</label>
    <div class="header-row" style="gap:10px; align-items:center;">
      <input id="import-account" type="text" size="60" placeholder="Paste your private key here" style="flex:1;">
      <button id="btn-scan-import" type="button" title="Scan QR">Scan QR</button>
    </div>
    <button id="btn-import">Use private key</button>
    <button id="btn-export">Export private key</button>
    <button id="btn-export-file">Download key file</button>
    <button id="btn-clear">Clear local private key</button>
    <div id="account-status" class="section-status" style="margin-top:10px;"></div>
  </div>

  <hr>

  <div id="dex-section">
    <h2>DEX</h2>
    <div class="toggle-row" style="margin-top:-6px;">
      <button id="btn-toggle-dex-note" type="button" class="toggle-link" data-toggle-target="dex-note" data-toggle-label-show="Show info" data-toggle-label-hide="Hide">Show info</button>
      <div id="dex-note" class="toggle-content" style="display:none;">
        <p style="opacity:0.85; margin-top:6px;">
          This is a non-custodial P2P exchange. The DEX never receives or holds your coins ‚Äî you pay the counterparty‚Äôs address directly.
          A watcher confirms the payment on-chain and tracks confirmations until settlement.
          <strong>Important: For multiple SELL orders, each order must use a different VECO address in ‚ÄúPay to address‚Äù. Do not reuse the same address across multiple SELL orders, otherwise a single payment can match multiple orders and lead to incorrect settlement.</strong>
        </p>
      </div>
    </div>

    <div class="dex-grid">
      <!-- Card 1: Create order -->
      <div class="dex-card">
        <h3 style="margin-top:0;">Create order</h3>

        <label for="dex-side">Side:</label>
        <select id="dex-side">
          <option value="SELL_CREDITS">SELL_CREDITS</option>
          <option value="BUY_CREDITS">BUY_CREDITS</option>
        </select>

        <label for="dex-currency">Currency:</label>
        <select id="dex-currency">
          <option value="VECO">VECO</option>
        </select>

        <label for="dex-credits">HCC amount:</label>
        <input id="dex-credits" type="number" min="1" step="1" value="5">

        <label for="dex-price">Price (coin per credit):</label>
        <input id="dex-price" type="number" min="0" step="0.00000001" value="0.2">

        <div id="dex-payto-wrap">
          <label for="dex-payto">Pay to address (where you receive the coin payment):</label>
          <input id="dex-payto" type="text" size="60" placeholder="Paste your coin address here">
        </div>

        <div style="display:flex; gap:10px; align-items:center; margin-top:10px;">
          <button id="btn-dex-place" type="button">Place order</button>
        </div>
        <div id="dex-status" class="section-status" style="margin-top:10px;"></div>
      </div>

      <!-- Card 2: Open orders -->
      <div class="dex-card">
        <h3 style="margin-top:0;">Open orders</h3>
        <small style="opacity:0.8;">Take creates a trade. Makers can cancel their own OPEN orders.</small>
        <div style="margin-top:10px;" id="dex-open-orders" class="dex-mono">Loading‚Ä¶</div>
      </div>

      <!-- Card 3: My trades -->
      <h3 style="margin-top:0; margin-bottom:0;">My trades</h3>
      <div class="toggle-row" style="margin-top:6px;">
        <button id="btn-toggle-dex-trades" type="button" class="toggle-link"
            data-toggle-target="dex-trades-wrap"
            data-toggle-label-show="Show trades"
            data-toggle-label-hide="Hide trades"
            data-default-open="desktop">Show trades</button>
      <div id="dex-trades-wrap" class="toggle-content" style="display:none;">
        <div class="header-row" style="margin-top:10px;">
          <small style="opacity:0.8;">Shows confirmations progress (confs / required) until settlement.</small>
          <button id="btn-dex-refresh" type="button">Refresh</button>
      </div>
      <div style="margin-top:10px;" id="dex-my-trades" class="dex-mono">Loading‚Ä¶</div>
    </div>
    </div>
    </div>
  </div>

  <hr>

    <section id="about">
      <h2>What is this?</h2>

      <div class="toggle-row" style="margin-top:-6px;">
        <button id="btn-toggle-about" type="button" class="toggle-link"
                data-toggle-target="about-wrap"
                data-toggle-label-show="Show"
                data-toggle-label-hide="Hide"
                data-default-open="desktop">Show</button>

        <div id="about-wrap" class="toggle-content" style="display:none;">
          <p>
            This small project is a tribute to Hashcash and early cypherpunks and combines two ideas:
          </p>
          <ul>
            <li>
              <strong><a href="https://en.wikipedia.org/wiki/Hashcash" target="_blank" rel="noopener noreferrer">Hashcash</a>-style Proof of Work:</strong>
              Every signup and claim requires solving a stateless PoW challenge, inspired by the original Hashcash anti-spam mechanism
              proposed by Adam Back in 1997.
            </li>
            <li>
              <strong>Crypto-inspired accounts:</strong>
              Each user gets a "private key" after a PoW signup challenge that is stored in this browser
              and used to authenticate with the server. The server tracks your HCC using an address derived from
              this private key, similar to a very simple wallet address, but never stores the key itself.
            </li>
            <li>
              <strong>No registration or personal data:</strong>
              You can create and use an account without email, username, or KYC. The server only sees anonymous
              keys and derived addresses, and there is no traditional signup form.
            </li>
            <li>
              <strong>Limited account creation per IP/day (demo rule):</strong>
              For fairness and to limit abuse, this demo only allows a limited number of signups per IP address per day.
            </li>
          </ul>
        </div>
      </div>
</section>

  <hr>

   <section id="disclaimer">
      <h2>Disclaimer</h2>

      <div class="toggle-row" style="margin-top:-6px;">
        <button id="btn-toggle-disclaimer" type="button" class="toggle-link"
                data-toggle-target="disclaimer-wrap"
                data-toggle-label-show="Show"
                data-toggle-label-hide="Hide"
                data-default-open="desktop">Show</button>

        <div id="disclaimer-wrap" class="toggle-content" style="display:none;">
          <p>
            Disclaimer: Credits (Hash Cash Credits - HCC) in this demo are play points only. They have no monetary value, do not represent a claim against us and have no fixed or implied exchange rate.
            Any crypto tip is purely discretionary, may be small, irregular or skipped entirely, and can be changed or discontinued at any time. There is no guaranteed probability,
            minimum or maximum payout and no right or expectation of any payment. The displayed ranges are not guaranteed and are provided for guidance only. The experimental DEX is non-custodial: we do not hold or escrow your coins; payments are made directly
            on-chain between users. Trades may fail, expire, or be delayed (including due to network conditions, confirmations, wrong amounts, or chain reorgs). Use at your own risk.
          </p>
        </div>
      </div>
   </section>

   <section id="links">
    <h2>Links</h2>
   <p>
      <a href="https://discord.gg/53w4DqaMqe" target="_blank" rel="noopener noreferrer">Discord</a>
   </p>
     <p>
      <a href="https://github.com/Hashcash-PoW-Faucet" target="_blank" rel="noopener noreferrer">Github</a>
   </p>
  </section>

  <!-- SHA256 library -->
  <script src="https://cdn.jsdelivr.net/npm/js-sha256@0.9.0/build/sha256.min.js"></script>

  <!-- QR code generator (for ‚ÄúShow QR‚Äù)
       IMPORTANT: self-host this file to avoid CDN MIME/nosniff/adblock issues.
       Place `qrcode.min.js` next to `index.html` or adjust the path below. -->
  <script src="./qrcode.min.js"></script>
  <script>
    // If QRCode is missing, we show a clear hint in the modal.
    if (!window.QRCode) {
      console.warn("QRCode library not found. Ensure ./qrcode.min.js is served from your domain.");
    }
  </script>

  <script>
    // const BASE_URL = "http://127.0.0.1:8200"; // backend FastAPI URL
    const BASE_URL = "/api"; //production

    // Persist the final signup payload so users can retry submit if the network/proxy fails.
    const PENDING_SIGNUP_KEY = "pending_signup_pow_v1";

    function setSignupRetryUI(visible, msg = "") {
      const btn = document.getElementById("btn-signup-retry");
      const hint = document.getElementById("signup-retry-hint");
      if (btn) btn.style.display = visible ? "" : "none";
      if (hint) hint.textContent = msg || "";
    }

    function describeFetchFailure(err, url) {
      const base = String(err || "");
      const parts = [];
      parts.push(`Network error while contacting the API (${url}).`);

      // Common gotchas
      if (window.location && window.location.protocol === "file:") {
        parts.push("It looks like you opened this page as a local file (file://). The API path '/api' will not work in that case ‚Äî please open the official faucet URL.");
      }
      if (window.location && window.location.protocol === "https:" && String(url).startsWith("http://")) {
        parts.push("Your browser may have blocked an insecure (http) request from an https page (mixed content).");
      }

      parts.push("Please check: 1) you are online, 2) adblock/VPN/privacy shields are not blocking the request, 3) the server/proxy is reachable.");
      parts.push("Good news: your PoW was saved locally ‚Äî you can click 'Retry signup submit' without re-mining.");

      if (base) parts.push("Details: " + base);
      return parts.join(" ");
    }

    function loadPendingSignup() {
      try {
        const raw = localStorage.getItem(PENDING_SIGNUP_KEY);
        if (!raw) return null;
        const obj = JSON.parse(raw);
        if (!obj || typeof obj !== "object") return null;
        return obj;
      } catch (e) {
        return null;
      }
    }

    function savePendingSignup(payload) {
      try {
        localStorage.setItem(PENDING_SIGNUP_KEY, JSON.stringify(payload));
      } catch (e) {
        // ignore
      }
    }

    function clearPendingSignup() {
      try {
        localStorage.removeItem(PENDING_SIGNUP_KEY);
      } catch (e) {
        // ignore
      }
    }
    let faucetConfig = null; // will be filled from /config
    let autoMineEnabled = false;
    let autoMineRunning = false;
    let lastAccountData = null; // last /me payload

    // Redeem log (server-backed, parsed from redeem_queue.jsonl)
    // This is meant to be a public faucet-style log.
    async function refreshRedeemLog() {
      const el = document.getElementById("redeem-log");
      if (!el) return;

      try {
        // Public/global log
        let res = await fetch(`${BASE_URL}/redeem_log?limit=10&all=true`, { method: "GET" });

        // Fallback: if public logs are disabled server-side, try per-account when we have a key.
        if (!res.ok && accountId) {
          res = await fetch(`${BASE_URL}/redeem_log?limit=10`, {
            method: "GET",
            headers: { "Authorization": "Bearer " + accountId }
          });
        }

        if (!res.ok) {
          let msg;
          try {
            const errData = await res.json();
            msg = errData.detail || JSON.stringify(errData);
          } catch (e) {
            msg = await res.text();
          }
          el.textContent = "Redeem log unavailable: " + msg;
          return;
        }

        const entries = await res.json();
        renderRedeemLog(entries);
      } catch (e) {
        console.error(e);
        el.textContent = "Redeem log error: " + e;
      }
    }

    function formatUnixTs(ts) {
      if (!ts || !Number.isFinite(ts)) return "-";
      return new Date(ts * 1000).toLocaleString();
    }

    function shortenAccountId(s) {
      if (!s) return "-";
      const str = String(s);
      if (str.length <= 16) return str;
      return str.slice(0, 10) + "‚Ä¶" + str.slice(-6);
    }

    function renderRedeemLog(entries) {
      const el = document.getElementById("redeem-log");
      if (!el) return;

      if (!entries || entries.length === 0) {
        el.textContent = "No redeems yet.";
        return;
      }

      // Newest first
      const lines = entries
        .slice()
        .reverse()
        .map((e) => {
          const req = e.request_id ?? e.id ?? "-";
          const ts = formatUnixTs(e.ts ?? e.created_at);
          const acc = shortenAccountId(e.account_id ?? "-");
          const cur = e.currency ?? "-";
          const amt = (e.tip_amount === 0 || e.tip_amount) ? String(e.tip_amount) : "-";
          const tx = e.txid ?? "-";
          const state = e.state ?? "-";
          const note = e.note ?? "";
          let out = `request_id=${req}\nts=${ts}\naccount_id=${acc}\ncurrency=${cur}\ntip_amount=${amt}\ntxid=${tx}\nstate=${state}`;
          if (note) {
            out += `\nnote=${note}`;
          }
          out += `\n---`;
          return out;
        });

      el.textContent = lines.join("\n");
    }

    async function loadConfig() {
      try {
        const res = await fetch(`${BASE_URL}/config`);
        if (!res.ok) {
          console.error("Failed to load config:", await res.text());
          return;
        }
        const cfg = await res.json();
        faucetConfig = cfg;
        populateDexCurrencies();

        // If present, update minimum redeem credits text in the redeem section
        const minRedeemEl = document.getElementById("min-redeem-credits");
        if (minRedeemEl && typeof cfg.min_redeem_credits === "number") {
          minRedeemEl.textContent = String(cfg.min_redeem_credits);
        }

        // If the backend exposes supported currencies, populate the redeem dropdown dynamically.
        const redeemCurrencySel = document.getElementById("redeem-currency");
        if (redeemCurrencySel && Array.isArray(cfg.supported_currencies) && cfg.supported_currencies.length > 0) {
          // Clear existing options and rebuild from config
          redeemCurrencySel.innerHTML = "";
          cfg.supported_currencies.forEach((sym) => {
            const opt = document.createElement("option");
            opt.value = sym;
            opt.textContent = sym;
            redeemCurrencySel.appendChild(opt);
          });
        }

        // Populate the info-section list of supported coins from cfg.coins (if present)
        const coinsContainer = document.getElementById("supported-coins");
        if (coinsContainer && cfg.coins && typeof cfg.coins === "object") {
          const symbols = Object.keys(cfg.coins);
          if (symbols.length > 0) {
            coinsContainer.innerHTML = "";
            symbols.sort().forEach((sym) => {
              const c = cfg.coins[sym] || {};
              const name = c.name || sym;
              const short = c.short || sym;
              const homepage = c.homepage || "";

              // Prefer explicit redeem keys if present; otherwise fall back to tip keys
              const minRedeem = c.min_redeem ?? c.min_tip ?? "";
              const maxRedeem = c.max_redeem ?? c.max_tip ?? "";

              const rangeSuffix =
                (minRedeem !== "" || maxRedeem !== "")
                //  ? ` ‚Äî redeem: ${minRedeem !== "" ? minRedeem : "?"}‚Äì${maxRedeem !== "" ? maxRedeem : "?"} ${short}`
                  ? ` up to ${maxRedeem !== "" ? maxRedeem : "?"} ${short}`
                  : "";

              const p = document.createElement("p");
              if (homepage) {
                const a = document.createElement("a");
                a.href = homepage;
                a.target = "_blank";
                a.rel = "noopener noreferrer";
                a.textContent = `${name} (${short})`;
                p.appendChild(a);

                // Add redeem range as plain text after the link
                if (rangeSuffix) p.appendChild(document.createTextNode(rangeSuffix));
              } else {
                p.textContent = `${name} (${short})${rangeSuffix}`;
              }
              coinsContainer.appendChild(p);
            });
          } else {
            coinsContainer.textContent = "No external coins configured.";
          }
        }
      } catch (err) {
        console.error("Error loading config:", err);
      }
    }

    // Web Worker for PoW (keeps the UI responsive)
    const powWorkerScript = `
      // Try to load SHA256 in a robust way.
      // 1) Prefer same-origin (recommended: self-host sha256.min.js)
      // 2) Fallback to CDN
      (function loadSha256(){
        try { self.importScripts('./sha256.min.js'); } catch (e) {}
        if (!self.sha256) {
          try { self.importScripts('https://cdn.jsdelivr.net/npm/js-sha256@0.9.0/build/sha256.min.js'); } catch (e) {}
        }
        if (!self.sha256) {
          // Signal a fatal error to the main thread; otherwise the UI would ‚Äúmine forever‚Äù.
          try { self.postMessage({ fatal: true, error: 'SHA256 library failed to load in worker. If you use an adblocker/privacy shield, it may block jsdelivr. Please self-host sha256.min.js next to index.html.' }); } catch (e) {}
        }
      })();

      self.onmessage = function (e) {
        const { message, bits, startNonce = 0, step = 1 } = e.data;
        let nonce = startNonce;
        const prefix = message + "|"; // reuse this string prefix for all hashes

        // Precompute threshold parameters for leading-zero-bits check
        const fullZeroBytes = bits >> 3;       // bits / 8
        const extraBits = bits & 7;            // bits % 8
        const partialMask = extraBits ? ((0xFF << (8 - extraBits)) & 0xFF) : 0;

        const t0 = Date.now();
        let lastReport = t0;

        while (true) {
          const input = prefix + nonce;
          // If the SHA256 lib failed to load, stop the worker cleanly.
          if (!self.sha256 || typeof self.sha256.array !== 'function') {
            self.postMessage({ fatal: true, error: 'SHA256 not available in worker (sha256.array missing). Please self-host sha256.min.js or disable blocking extensions.' });
            break;
          }

          const digest = sha256.array(input);

          // Fast check: required number of leading zero bytes + optional partial byte
          let ok = true;

          // Check full zero bytes
          for (let i = 0; i < fullZeroBytes; i++) {
            if (digest[i] !== 0) {
              ok = false;
              break;
            }
          }

          // If still ok and we need extra bits, check the partial byte with a mask
          if (ok && extraBits) {
            if ((digest[fullZeroBytes] & partialMask) !== 0) {
              ok = false;
            }
          }

          if (ok) {
            const dt = (Date.now() - t0) / 1000;
            const rate = nonce > 0 && dt > 0 ? nonce / dt : 0;
            self.postMessage({ nonce: String(nonce), time: dt, rate, done: true });
            break;
          }

          nonce += step;

          // Periodic progress updates (about every 500 ms)
          if (nonce % 50000 === 0) {
            const now = Date.now();
            if (now - lastReport >= 500) {
              const dt = (now - t0) / 1000;
              const rate = nonce > 0 && dt > 0 ? nonce / dt : 0;
              self.postMessage({ nonce: String(nonce), time: dt, rate, done: false });
              lastReport = now;
            }
          }
        }
      };
    `;
    const powWorkerBlob = new Blob([powWorkerScript], { type: 'application/javascript' });
    const powWorkerUrl = URL.createObjectURL(powWorkerBlob);

    // Multi-worker pool state
    let powWorkers = [];
    let powWorkerHandlers = [];
    let powWorkerErrorHandlers = [];
    let activePowReject = null;

    function cleanupPowWorkers() {
      for (let i = 0; i < powWorkers.length; i++) {
        const w = powWorkers[i];
        const h = powWorkerHandlers[i];
        const eh = powWorkerErrorHandlers[i];
        try {
          if (w && h) w.removeEventListener("message", h);
          if (w && eh) w.removeEventListener("error", eh);
        } catch (e) {}
        try {
          if (w) w.terminate();
        } catch (e) {}
      }
      powWorkers = [];
      powWorkerHandlers = [];
      powWorkerErrorHandlers = [];
    }

    function stopMining(reason = "Mining stopped by user.") {
      // Stop auto-mine if it is running
      autoMineEnabled = false;
      const cb = document.getElementById("auto-mine-checkbox");
      if (cb) cb.checked = false;

      // If a PoW is running, terminate workers and reject the pending promise
      if (activePowReject) {
        const rej = activePowReject;
        activePowReject = null;

        cleanupPowWorkers();
        rej(new Error(reason));

        // IMPORTANT: Release the server-side IP lock for claim-PoW immediately.
        // Otherwise the IP stays blocked until STAMP_TTL_SEC expires.
        // (Signup PoW does not use the /challenge IP lock, but this call is harmless.)
        if (accountId) {
          fetch(`${BASE_URL}/cancel_pow`, {
            method: "POST",
            headers: {
              "Authorization": "Bearer " + accountId,
              "Content-Type": "application/json",
            },
            body: JSON.stringify({}),
          }).catch(() => {});
        }
      }

      setMiningActive(false);
      setStatus(reason);
    }

    function setStopButtonsVisible(visible) {
      const ids = ["btn-stop-mining", "btn-stop-mining-signup"];
      ids.forEach((id) => {
        const b = document.getElementById(id);
        if (b) b.style.display = visible ? "" : "none";
      });
    }

    // Keep a short history of hashrate samples (for ~3s moving average)
    let hashrateSamples = [];

    function resetHashrateUI() {
      hashrateSamples = [];
      setHashrate(null);
    }

    function addHashrateSample(rate) {
      const now = performance.now() / 1000; // seconds
      hashrateSamples.push({ t: now, r: rate });
      const cutoff = now - 3.0;
      hashrateSamples = hashrateSamples.filter(s => s.t >= cutoff);
      if (hashrateSamples.length === 0) {
        setHashrate(null);
        return;
      }
      const sum = hashrateSamples.reduce((acc, s) => acc + s.r, 0);
      // Interpret sum of recent per-worker rates as the total hashrate.
      setHashrate(sum);
    }

    function getPowWorkerCount() {
      const input = document.getElementById("pow-threads");
      const hc = navigator.hardwareConcurrency || 0;
      let n = input ? parseInt(input.value, 10) : NaN;

      // Fallback: if input invalid, default to hardwareConcurrency or 1.
      if (!Number.isFinite(n) || n <= 0) {
        n = hc || 1;
      }

      // Clamp to hardwareConcurrency if available.
      if (hc && n > hc) {
        n = hc;
      }

      if (!Number.isFinite(n) || n <= 0) {
        n = 1;
      }
      return n;
    }

    function solvePow(message, bits) {
      return new Promise((resolve, reject) => {
        const numWorkers = getPowWorkerCount();

        // If there is a previous active PoW, cancel it first.
        if (activePowReject) {
          try {
            activePowReject(new Error("Previous mining canceled."));
          } catch (e) {
            // ignore
          }
          activePowReject = null;
        }

        cleanupPowWorkers();
        let resolved = false;
        let sawAnyWorkerMessage = false;

        // Register this promise so stopMining() can cancel it.
        activePowReject = (err) => {
          if (!resolved) {
            resolved = true;
            cleanupPowWorkers();
            reject(err);
          }
        };

        for (let i = 0; i < numWorkers; i++) {
          const w = new Worker(powWorkerUrl);
          const errHandler = (ev) => {
            if (!resolved) {
              resolved = true;
              cleanupPowWorkers();
              activePowReject = null;
              const msg = (ev && ev.message) ? ev.message : "PoW worker crashed.";
              reject(new Error(msg + " (Likely: blocked SHA256 importScripts or a worker runtime error.)"));
            }
          };
          w.addEventListener("error", errHandler);
          const handler = (event) => {
            const { nonce, time, rate, done, fatal, error } = (event && event.data) ? event.data : {};
            if (fatal) {
              if (!resolved) {
                resolved = true;
                cleanupPowWorkers();
                activePowReject = null;
                reject(new Error(error || "PoW worker reported a fatal error."));
              }
              return;
            }
            sawAnyWorkerMessage = true;
            if (rate && isFinite(rate)) {
              addHashrateSample(rate);
            }
            if (done && !resolved) {
              resolved = true;
              cleanupPowWorkers();
              activePowReject = null;
              resolve(String(nonce));
            }
          };
          w.addEventListener("message", handler);
          powWorkers.push(w);
          powWorkerHandlers.push(handler);
          powWorkerErrorHandlers.push(errHandler);
          w.postMessage({ message, bits, startNonce: i, step: numWorkers });
        }

        // Watchdog: if workers never post anything, they likely failed to start (e.g. importScripts blocked).
        setTimeout(() => {
          if (!resolved && !sawAnyWorkerMessage) {
            try {
              if (activePowReject) activePowReject(new Error("PoW worker did not start. Likely blocked script import (adblock/privacy shields). Please self-host sha256.min.js next to index.html."));
            } catch (e) {}
          }
        }, 1500);
      });
    }

let accountId = localStorage.getItem("account_id") || null;
let currentAddress = null;     // derived address from the backend
let serverTimeOffset = 0;     // server_time - local_time (seconds)
let lastCooldownUntil = 0;    // unix timestamp from backend

// UI: hide cooldown row while PoW is actively running, and only show it when cooldown is actually counting down.
let miningActive = false;

// Track the currently running PoW difficulty so we can show an ETA next to the hashrate.
let currentPowBits = null;   // e.g. 26
let currentPowMode = "";     // "signup" | "claim" | ""

function setMiningActive(active) {
  miningActive = !!active;

  // When mining stops, hide any previously shown hashrate value and clear the current PoW context.
  if (!miningActive) {
    currentPowBits = null;
    currentPowMode = "";
    resetHashrateUI();
  }

  setStopButtonsVisible(miningActive);

  // Ensure the helper line under Signup updates immediately.
  // (During signup PoW we want to hide the "No private key loaded..." text.)
  setAccountInfo();

  // Update cooldown row visibility immediately
  updateCooldownCountdown();
}

    function leadingZeroBits(bytes) {
      let bits = 0;
      for (let i = 0; i < bytes.length; i++) {
        const b = bytes[i];
        if (b === 0) {
          bits += 8;
        } else {
          for (let j = 7; j >= 0; j--) {
            if (((b >> j) & 1) === 0) {
              bits += 1;
            } else {
              return bits;
            }
          }
          return bits;
        }
      }
      return bits;
    }

    function b64urlRandom(len = 18) {
      const arr = new Uint8Array(len);
      crypto.getRandomValues(arr);
      let s = btoa(String.fromCharCode(...arr));
      // base64url encoding
      return s.replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
    }

    function setSectionStatus(elementId, msg) {
      const el = document.getElementById(elementId);
      if (!el) return;
      el.textContent = msg;
    }

    // Earn/claim status (kept in the top status panel)
    function setStatus(msg) {
      // Main status line (visible after account exists)
      setSectionStatus("status", msg);

      // Before signup is completed, the main status panel is hidden.
      // Mirror messages into the signup section so users still see progress.
      if (!accountId) {
        setSectionStatus("signup-status", msg);
      }

      console.log(msg);
    }

    // Section-specific status fields
    function setAccountStatus(msg) {
      setSectionStatus("account-status", msg);
      console.log(msg);
    }

    function setSendStatus(msg) {
      setSectionStatus("send-status", msg);
      console.log(msg);
    }

    function setRedeemStatus(msg) {
      setSectionStatus("redeem-status", msg);
      console.log(msg);
    }

    function setAccountInfo() {
      const el = document.getElementById("account-info");
      if (!el) return;

      if (accountId) {
        el.textContent = "Private key is stored in this browser.";
        return;
      }

      // During signup PoW we show progress in the signup status box; this line is redundant.
      if (miningActive) {
        el.textContent = "";
        return;
      }

      el.textContent = "No private key loaded. Perform signup PoW task or import private key.";
    }

    function setCredits(msg) {
      const el = document.getElementById("credits");
      if (!el) return;

      const raw = String(msg ?? "").trim();
      if (!raw) {
        el.textContent = "";
        return;
      }

      // If caller already included the unit, do not duplicate.
      if (/\bHCC\b/i.test(raw)) {
        el.textContent = raw;
      } else {
        el.textContent = raw + " HCC";
      }
    }

    function setHashrate(hashesPerSecond) {
      const el = document.getElementById("hashrate");
      const signupEl = document.getElementById("signup-hashrate");

      const hasRate = !!(hashesPerSecond && isFinite(hashesPerSecond));

      // When we are not actively mining, hide both hashrate lines.
      if (!hasRate) {
        if (el) {
          el.textContent = "";
          el.style.display = "none";
        }
        if (signupEl) {
          signupEl.textContent = "";
          signupEl.style.display = "none";
        }
        return;
      }

      const khs = hashesPerSecond / 1000;

      // Expected time to a valid hit for leading-zero-bits PoW is ~ 2^bits / hashrate.
      // (Exponential distribution; this is the mean.)
      let etaSuffix = "";
      if (currentPowBits && Number.isFinite(currentPowBits) && currentPowBits > 0) {
        const expectedHashes = Math.pow(2, currentPowBits);
        const expectedSeconds = expectedHashes / hashesPerSecond;
        if (Number.isFinite(expectedSeconds) && expectedSeconds > 0) {
          const eta = formatDurationHMS(expectedSeconds);
          etaSuffix = `\navg hit: ~${eta}`;
        }
      }

      const txt = "Hashrate: " +
        khs.toLocaleString(undefined, { maximumFractionDigits: 1 }) +
        " kH/s" +
        etaSuffix;

      // Normal (logged-in) display
      if (el) {
        el.style.display = "";
        el.textContent = txt;
      }

      // Signup display (before account exists, the status panel is hidden)
      if (!accountId && signupEl) {
        signupEl.style.display = "";
        signupEl.textContent = txt;
      } else if (signupEl) {
        // Once logged in, keep the signup hashrate hidden.
        signupEl.textContent = "";
        signupEl.style.display = "none";
      }
    }

    // Helper to copy address to clipboard and show status
    async function copyAddressToClipboard(addr) {
      if (!addr) {
        setAccountStatus("No address to copy.");
        return;
      }
      try {
        if (navigator.clipboard && navigator.clipboard.writeText) {
          await navigator.clipboard.writeText(addr);
        } else {
          // Fallback for older browsers
          const ta = document.createElement("textarea");
          ta.value = addr;
          document.body.appendChild(ta);
          ta.select();
          document.execCommand("copy");
          document.body.removeChild(ta);
        }
        setAccountStatus("Address copied to clipboard.");
      } catch (err) {
        console.error(err);
        setAccountStatus("Failed to copy address: " + err);
      }
    }

    // Visual feedback for successful PoW
    let powSuccessTimer = null;
    function triggerPowSuccess() {
      const panel = document.getElementById("status-panel");
      if (!panel) return;

      panel.classList.remove("pow-success");
      void panel.offsetWidth; // restart animation
      panel.classList.add("pow-success");

      if (powSuccessTimer) clearTimeout(powSuccessTimer);
      powSuccessTimer = setTimeout(() => {
        panel.classList.remove("pow-success");
        powSuccessTimer = null;
      }, 1700);
    }

// ---------------------------
// QR helpers (Show QR + Scan QR)
// ---------------------------
let qrModalText = "";
let qrScanStream = null;
let qrScanStop = null;
let qrScanTargetInputId = null;

function openQrModal(title, text) {
  const overlay = document.getElementById("qr-modal");
  const titleEl = document.getElementById("qr-modal-title");
  const textEl = document.getElementById("qr-modal-text");
  const qrBox = document.getElementById("qr-box");
  const canvas = document.getElementById("qr-canvas");
  const hintEl = document.getElementById("qr-render-hint");
  const closeBtn = document.getElementById("btn-qr-close");
  const copyBtn = document.getElementById("btn-qr-copy");

  if (!overlay || !titleEl || !textEl) return;

  qrModalText = String(text || "");
  titleEl.textContent = title || "QR";
  textEl.textContent = qrModalText;

  overlay.style.display = "flex";

  // Reset previous render state
  if (qrBox) {
    qrBox.innerHTML = "";
    qrBox.style.display = "none";
  }
  if (canvas) {
    const ctx = canvas.getContext && canvas.getContext("2d");
    if (ctx) ctx.clearRect(0, 0, canvas.width || 0, canvas.height || 0);
    canvas.style.display = "none";
  }
  if (hintEl) {
    hintEl.textContent = "";
    hintEl.style.display = "none";
  }

  // Render QR (support both node-qrcode and qrcodejs APIs)
  try {
    if (!window.QRCode) {
      console.warn("QRCode lib not available");
      if (hintEl) {
        hintEl.textContent = "QR library not loaded. Please self-host qrcode.min.js (e.g. ./qrcode.min.js next to index.html) and make sure it is served with Content-Type application/javascript.";
        hintEl.style.display = "";
      }
    } else {
      const opts = {
        margin: 2,
        width: 260,
        color: {
          dark: "#111827", // dark modules
          light: "#ffffff" // light background
        }
      };

      // A) "qrcode" (node-qrcode) style API: QRCode.toCanvas / QRCode.toDataURL
      if (typeof window.QRCode.toCanvas === "function" && canvas) {
        canvas.style.display = "";
        window.QRCode.toCanvas(canvas, qrModalText, opts, function (err) {
          if (err) {
            console.error(err);
            if (hintEl) {
              hintEl.textContent = "QR render failed: " + err;
              hintEl.style.display = "";
            }
          }
        });
      }
      else if (typeof window.QRCode.toDataURL === "function" && qrBox) {
        // If someone ships only toDataURL, render into an <img> we create on the fly.
        window.QRCode.toDataURL(qrModalText, opts, function (err, url) {
          if (err) {
            console.error(err);
            if (hintEl) {
              hintEl.textContent = "QR render failed: " + err;
              hintEl.style.display = "";
            }
            return;
          }
          const im = document.createElement("img");
          im.alt = "QR";
          im.src = url;
          im.style.width = "260px";
          im.style.height = "260px";
          im.style.borderRadius = "10px";
          qrBox.appendChild(im);
          qrBox.style.display = "";
        });
      }
      // B) "qrcodejs" style API: new QRCode(element, options)
      else if (typeof window.QRCode === "function" && qrBox) {
        qrBox.style.display = "";
        // qrcodejs expects colorDark/colorLight and does not understand our opts object
        const qropts = {
          text: qrModalText,
          width: 260,
          height: 260,
          colorDark: "#111827",
          colorLight: "#ffffff",
        };
        try {
          // If CorrectLevel exists, use a sensible default.
          if (window.QRCode.CorrectLevel && window.QRCode.CorrectLevel.M) {
            qropts.correctLevel = window.QRCode.CorrectLevel.M;
          }
          new window.QRCode(qrBox, qropts);
        } catch (e) {
          console.error(e);
          if (hintEl) {
            hintEl.textContent = "QR render failed: " + e;
            hintEl.style.display = "";
          }
        }
      }
      else {
        if (hintEl) {
          hintEl.textContent = "QR library loaded, but no renderer available (unexpected build). Please ensure you are serving a browser build that provides QRCode.toCanvas(...) or use a qrcodejs build.";
          hintEl.style.display = "";
        }
      }
    }
  } catch (e) {
    console.error(e);
    if (hintEl) {
      hintEl.textContent = "QR error: " + e;
      hintEl.style.display = "";
    }
  }

  const close = () => closeQrModal();
  if (closeBtn) closeBtn.onclick = close;
  overlay.onclick = (ev) => {
    if (ev.target === overlay) close();
  };
  if (copyBtn) {
    copyBtn.onclick = () => {
      copyAddressToClipboard(qrModalText);
    };
  }
}

function closeQrModal() {
  const overlay = document.getElementById("qr-modal");
  if (overlay) overlay.style.display = "none";

  const qrBox = document.getElementById("qr-box");
  const canvas = document.getElementById("qr-canvas");
  const hintEl = document.getElementById("qr-render-hint");

  if (qrBox) {
    qrBox.innerHTML = "";
    qrBox.style.display = "none";
  }
  if (canvas) {
    const ctx = canvas.getContext && canvas.getContext("2d");
    if (ctx) ctx.clearRect(0, 0, canvas.width || 0, canvas.height || 0);
    canvas.style.display = "none";
  }
  if (hintEl) {
    hintEl.textContent = "";
    hintEl.style.display = "none";
  }

  qrModalText = "";
}

function setQrScanStatus(msg) {
  const el = document.getElementById("qr-scan-status");
  if (el) el.textContent = msg || "";
}

async function openQrScanner(targetInputId) {
  qrScanTargetInputId = targetInputId;
  const overlay = document.getElementById("qr-scan-modal");
  const video = document.getElementById("qr-video");
  const closeBtn = document.getElementById("btn-qr-scan-close");
  const stopBtn = document.getElementById("btn-qr-scan-stop");

  if (!overlay || !video) return;

  // Prefer native BarcodeDetector if available (Chrome/Brave/Android works well)
  const hasDetector = !!window.BarcodeDetector;
  if (!hasDetector) {
    setQrScanStatus("QR scanning is not supported in this browser (BarcodeDetector missing). Try Chrome/Brave or the installed PWA.");
    overlay.style.display = "flex";
    // Make sure the camera modal is immediately visible on mobile
    try {
      window.scrollTo({ top: 0, left: 0, behavior: "instant" });
    } catch (e) {
      window.scrollTo(0, 0);
    }

// Prevent background scrolling while the modal is open
try { document.body.style.overflow = "hidden"; } catch (e) {}

    if (closeBtn) closeBtn.onclick = () => closeQrScanner();
    if (stopBtn) stopBtn.onclick = () => closeQrScanner();
    overlay.onclick = (ev) => { if (ev.target === overlay) closeQrScanner(); };
    return;
  }

  overlay.style.display = "flex";
  setQrScanStatus("Requesting camera‚Ä¶");

  // Make sure the camera modal is immediately visible on mobile
  try {
    window.scrollTo({ top: 0, left: 0, behavior: "instant" });
  } catch (e) {
    window.scrollTo(0, 0);
  }

  // Prevent background scrolling while the modal is open
  try { document.body.style.overflow = "hidden"; } catch (e) {}

  const close = () => closeQrScanner();
  if (closeBtn) closeBtn.onclick = close;
  if (stopBtn) stopBtn.onclick = close;
  overlay.onclick = (ev) => { if (ev.target === overlay) close(); };

  try {
    qrScanStream = await navigator.mediaDevices.getUserMedia({
      video: { facingMode: "environment" },
      audio: false
    });
    video.srcObject = qrScanStream;
    await video.play();

    setQrScanStatus("Point the camera at a QR code‚Ä¶");

    const detector = new BarcodeDetector({ formats: ["qr_code"] });
    let stopped = false;
    qrScanStop = () => { stopped = true; };

    const tick = async () => {
      if (stopped) return;
      try {
        const barcodes = await detector.detect(video);
        if (barcodes && barcodes.length > 0) {
          const val = String(barcodes[0].rawValue || "").trim();
          if (val) {
            const input = document.getElementById(qrScanTargetInputId);
            if (input) input.value = val;
            setQrScanStatus("Scanned ‚úÖ");
            setTimeout(() => closeQrScanner(), 250);
            return;
          }
        }
      } catch (e) {
        // transient errors while warming up are ok
      }
      requestAnimationFrame(tick);
    };

    requestAnimationFrame(tick);
  } catch (e) {
    console.error(e);
    setQrScanStatus("Camera error: " + e);
  }
}

function closeQrScanner() {
  const overlay = document.getElementById("qr-scan-modal");
  const video = document.getElementById("qr-video");
  if (qrScanStop) {
    try { qrScanStop(); } catch (e) {}
    qrScanStop = null;
  }
  if (qrScanStream) {
    try { qrScanStream.getTracks().forEach((t) => t.stop()); } catch (e) {}
    qrScanStream = null;
  }
  if (video) {
    try { video.pause(); } catch (e) {}
    video.srcObject = null;
  }
  // Restore background scrolling
  try { document.body.style.overflow = ""; } catch (e) {}
  if (overlay) overlay.style.display = "none";
  setQrScanStatus("");
  qrScanTargetInputId = null;
}

function updateVisibility() {
  // Keep a CSS-readable flag in sync (also helps if later JS errors prevent manual style toggles)
  try {
    document.documentElement.dataset.hasAccount = accountId ? "1" : "0";
  } catch (e) {}

  const isMobile = window.matchMedia && window.matchMedia("(max-width: 640px)").matches;

  const signupSection = document.getElementById("signup-section");
  const earnSection = document.getElementById("earn-section");
  const statusSection = document.getElementById("status-panel");
  const desktopStatusBlock = document.getElementById("desktop-status-block");
  const accountSection = document.getElementById("account-section");
  const sendSection = document.getElementById("send-section");
  const redeemSection = document.getElementById("redeem-section");
  const dexSection = document.getElementById("dex-section");

  // Account management (including private key import) should always be visible
  if (accountSection) accountSection.style.display = "";

  if (accountId) {
    if (signupSection) signupSection.style.display = "none";
    if (desktopStatusBlock) desktopStatusBlock.style.display = isMobile ? "none" : "";
    if (statusSection) statusSection.style.display = isMobile ? "none" : "";
    if (earnSection) earnSection.style.display = "";
    if (sendSection) sendSection.style.display = "";
    if (redeemSection) redeemSection.style.display = "";
    if (dexSection) dexSection.style.display = "";
  } else {
    if (signupSection) signupSection.style.display = "";
    if (desktopStatusBlock) desktopStatusBlock.style.display = "none";
    if (statusSection) statusSection.style.display = "none";
    if (earnSection) earnSection.style.display = "none";
    if (sendSection) sendSection.style.display = "none";
    if (redeemSection) redeemSection.style.display = "none";
    if (dexSection) dexSection.style.display = "none";
  }

  // Hide the info note when an account is loaded
  const infoAccountReqNote = document.getElementById("info-account-required-note");
  if (infoAccountReqNote) {
    infoAccountReqNote.style.display = accountId ? "none" : "";
  }

  // Mobile-only UI (sticky topbar + quick actions)
  const mobileTopbar = document.getElementById("mobile-topbar");
  const mobileQuick = document.getElementById("mobile-quick-actions");
  const mobileMenu = document.getElementById("mobile-menu");

  const showMobile = !!(accountId && isMobile);
  if (mobileTopbar) mobileTopbar.style.display = showMobile ? "" : "none";
  if (mobileQuick) mobileQuick.style.display = showMobile ? "" : "none";
  if (!showMobile && mobileMenu) mobileMenu.style.display = "none";
}


    function setupToggleNotes() {
      const buttons = document.querySelectorAll('button[data-toggle-target]');
      buttons.forEach((btn) => {
        const targetId = btn.getAttribute('data-toggle-target');
        const labelShow = btn.getAttribute('data-toggle-label-show') || 'Show info';
        const labelHide = btn.getAttribute('data-toggle-label-hide') || 'Hide';
        btn.type = 'button';
        const target = targetId ? document.getElementById(targetId) : null;
        if (!target) return;

        const isMobile = window.matchMedia && window.matchMedia("(max-width: 640px)").matches;
        const def = (btn.getAttribute('data-default-open') || '').toLowerCase();
        const shouldOpen = (def === 'true') || (def === 'desktop' && !isMobile);

        if (shouldOpen) {
          target.setAttribute('data-open', '1');
          //target.style.display = 'block';
          btn.setAttribute('aria-expanded', 'true');
          btn.textContent = labelHide;
        } else {
          target.removeAttribute('data-open');
          //target.style.display = 'none';
          btn.setAttribute('aria-expanded', 'false');
          btn.textContent = labelShow;
        }

        // IMPORTANT: do not stack listeners
        btn.onclick = () => {
          const isOpen = target.getAttribute('data-open') === '1';
          if (isOpen) {
            target.removeAttribute('data-open');
            //target.style.display = 'none';
            btn.setAttribute('aria-expanded', 'false');
            btn.textContent = labelShow;
          } else {
            target.setAttribute('data-open', '1');
            //target.style.display = 'block';
            btn.setAttribute('aria-expanded', 'true');
            btn.textContent = labelHide;
          }
        };
      });
    }

function shortenAccountIdTiny(s) {
  if (!s) return "-";
  const str = String(s);
  if (str.length <= 14) return str;
  return str.slice(0, 6) + "‚Ä¶" + str.slice(-4);
}

function setupMobileNav() {
  // Guard: ensure we only attach global listeners once
  if (!window.__mobileNavInit) window.__mobileNavInit = { outsideClickBound: false };

  const gear = document.getElementById("btn-mobile-gear");
  const menu = document.getElementById("mobile-menu");

  if (gear && menu) {
    if (!menu.style.display) menu.style.display = "none";

    // Idempotent: overwrite handler instead of addEventListener
    gear.onclick = (ev) => {
      ev.preventDefault();
      ev.stopPropagation();
      const isOpen = (menu.style.display === "block");
      menu.style.display = isOpen ? "none" : "block";
    };

    // Close when tapping outside (bind only once)
    if (!window.__mobileNavInit.outsideClickBound) {
      window.__mobileNavInit.outsideClickBound = true;
      document.addEventListener("click", (ev) => {
        const g = document.getElementById("btn-mobile-gear");
        const m = document.getElementById("mobile-menu");
        if (!m || m.style.display !== "block") return;
        if (g && ev.target === g) return;
        if (m.contains(ev.target)) return;
        m.style.display = "none";
      });
    }
  } else {
    if (!gear) console.warn("Mobile gear button not found: #btn-mobile-gear");
    if (!menu) console.warn("Mobile menu container not found: #mobile-menu");
  }

  // Mobile: show address QR
  const showQr = document.getElementById("btn-mobile-show-qr");
  if (showQr) {
    showQr.onclick = (ev) => {
      ev.preventDefault();
      if (lastAccountData && lastAccountData.account_id) {
        openQrModal("Address", lastAccountData.account_id);
      } else if (accountId) {
        openQrModal("Address", accountId);
      }
    };
  }

  const go = (id) => {
    const el = document.getElementById(id);
    if (!el) return;
    el.scrollIntoView({ behavior: "smooth", block: "start" });
  };

  const b1 = document.getElementById("btn-mobile-go-earn");
  const b2 = document.getElementById("btn-mobile-go-send");
  const b3 = document.getElementById("btn-mobile-go-redeem");
  if (b1) b1.onclick = (ev) => { ev.preventDefault(); go("earn-section"); };
  if (b2) b2.onclick = (ev) => { ev.preventDefault(); go("send-section"); };
  if (b3) b3.onclick = (ev) => { ev.preventDefault(); go("redeem-section"); };
}

// Wire QR scan buttons (keep this block error-free; a ReferenceError here stops all subsequent JS, incl. loadConfig()).
const scanSend = document.getElementById("btn-scan-send");
if (scanSend) scanSend.onclick = (ev) => { ev.preventDefault(); openQrScanner("send-to-address"); };

const scanRedeem = document.getElementById("btn-scan-redeem");
if (scanRedeem) scanRedeem.onclick = (ev) => { ev.preventDefault(); openQrScanner("redeem-address"); };

const scanImport = document.getElementById("btn-scan-import");
if (scanImport) scanImport.onclick = (ev) => { ev.preventDefault(); openQrScanner("import-account"); };

// One-time UI initialization (idempotent)
if (!window.__uiInitDone) {
  window.__uiInitDone = true;
  try { setupToggleNotes(); } catch (e) {}
  try { setupMobileNav(); } catch (e) {}
  try { updateVisibility(); } catch (e) {}
}

// Bind resize handler only once
if (!window.__uiResizeBound) {
  window.__uiResizeBound = true;
  window.addEventListener("resize", () => updateVisibility());
}

// (moved) UI init + resize binding are handled above (guarded)




    function updateCooldownCountdown() {
      const el = document.getElementById("cooldown-countdown");
      if (!el) return;

      // Default: hide the row unless we are actively counting down.
      el.style.display = "none";
      el.textContent = "";

      if (!accountId || !lastCooldownUntil) {
        return;
      }

      // While PoW is running, cooldown info is not useful.
      if (miningActive) {
        return;
      }

      const nowLocal = Math.floor(Date.now() / 1000);
      const serverNow = nowLocal + serverTimeOffset;
      const remaining = lastCooldownUntil - serverNow;

      // If ready (or negative), keep hidden.
      if (remaining <= 0) {
        return;
      }

      // hide hashrate while cooldown is running
      resetHashrateUI();

      const minutes = Math.floor(remaining / 60);
      const seconds = remaining % 60;
      el.style.display = "";
      el.textContent = `Cooldown remaining: ${minutes}m ${seconds}s`;
    }

    // Update countdown once per second
    setInterval(updateCooldownCountdown, 1000);



    async function checkSignupStatus() {
      const res = await fetch(`${BASE_URL}/signup_status`);
      const st = await res.json();
      if (!st.allowed) {
        setStatus(`Signup not allowed from this IP: ${st.detail} (remaining today: 0)`);
        return false;
      }
      return true;
    }

    async function signup() {
      if (accountId) {
        setStatus("Account already exists, skipping signup.");
        return;
      }

      const ok = await checkSignupStatus();
      if (!ok) {
        return; // don't start PoW
      }

      const bits = faucetConfig && typeof faucetConfig.signup_bits === "number"
        ? faucetConfig.signup_bits
        : 24; // safe fallback if config not loaded

      setStatus(`Running signup PoW (bits=${bits})... This can take a few minutes or even hours but needs to be done only once. Note: only a limited number of accounts can be created per IP address; if the limit is already reached, signup will fail with "signup cap per ip" even after PoW.`);

      const ts = Math.floor(Date.now() / 1000);
      const clientNonce = b64urlRandom(18);
      const rounded = Math.floor(ts / 60) * 60;
      const msg = `signup|ts=${rounded}|cn=${clientNonce}`;

      currentPowBits = bits;
      currentPowMode = "signup";
      setMiningActive(true);
      let powNonce;
      try {
        powNonce = await solvePow(msg, bits);
      } catch (e) {
        if (String(e || "").toLowerCase().includes("mining stopped")) {
          // User canceled
          return;
        }
        throw e;
      } finally {
        setMiningActive(false);
      }

      const payload = {
        client_nonce: clientNonce,
        pow_nonce: powNonce,
        ts: ts
      };

      // Save the payload so the user can retry submit if the network/proxy fails.
      savePendingSignup(payload);

      // Try to submit (may fail with a fetch network error).
      await submitSignupPow(payload);
    }

    async function submitSignupPow(payload) {
      const url = `${BASE_URL}/signup_pow`;
      setSignupRetryUI(false, "");

      try {
        const res = await fetch(url, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload)
        });

        if (!res.ok) {
          const text = await res.text();
          // Server responded (so this is not a network-level fetch failure)
          setStatus("Signup failed: " + text);
          setSignupRetryUI(true, "Server rejected the signup. If this was a temporary issue, you can retry. Otherwise you may need to mine a new signup later.");
          return;
        }

        const data = await res.json();
        accountId = data.account_id;
        localStorage.setItem("account_id", accountId);

        // Success: clear pending payload and hide retry UI
        clearPendingSignup();
        setSignupRetryUI(false, "");

        updateVisibility();
        setAccountInfo();
        const importInput = document.getElementById("import-account");
        if (importInput) {
          importInput.value = accountId;
        }
        setStatus("Signup ok. A new private key has been created. Please back it up using 'Export private key'.");
        triggerPowSuccess();
        await refreshAccount();
        refreshRedeemLog();
      } catch (err) {
        console.error(err);
        // Network/proxy/browser blocked the request (classic: TypeError: Failed to fetch)
        setStatus("Error: " + describeFetchFailure(err, url));
        setSignupRetryUI(true, "Your PoW is saved locally. Click 'Retry signup submit' once the connection works again.");
      }
    }

    async function earnCredit() {
      if (!accountId) {
        setStatus("No account ‚Äì please run signup or import an account.");
        return;
      }
      setStatus("Requesting challenge...");

      const resCh = await fetch(`${BASE_URL}/challenge`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": "Bearer " + accountId
        },
        body: JSON.stringify({ action: "earn_credit" })
      });

      if (!resCh.ok) {
        const text = await resCh.text();
        setStatus("Challenge failed: " + text);
        return;
      }

      const ch = await resCh.json();
      const stamp = ch.stamp;
      const bits = ch.bits;
      const sig = ch.sig;

      setStatus(`Running claim PoW (bits=${bits})...`);
      currentPowBits = bits;
      currentPowMode = "claim";
      setMiningActive(true);
      let nonce;
      try {
        nonce = await solvePow(stamp, bits);
      } catch (e) {
        if (String(e || "").toLowerCase().includes("mining stopped")) {
          // User canceled
          return;
        }
        throw e;
      } finally {
        setMiningActive(false);
      }

      const resSub = await fetch(`${BASE_URL}/submit_pow`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": "Bearer " + accountId
        },
        body: JSON.stringify({ stamp, sig, nonce })
      });

      if (!resSub.ok) {
        const text = await resSub.text();
        setStatus("Submit failed: " + text);
        return;
      }

      const data = await resSub.json();
      setStatus("Claim ok. Cooldown updated.");
      triggerPowSuccess();
      await refreshAccount();
      refreshRedeemLog();
    }

    async function autoMineLoop() {
      if (autoMineRunning) return;
      autoMineRunning = true;
      setStatus("Auto-mine started. The miner will run until the daily cap is reached, pausing during cooldown.");
      try {
        while (autoMineEnabled && accountId) {

          await refreshAccount();
          if (!lastAccountData) {
            setStatus("Auto-mine stopped: unable to load account info.");
            break;
          }

          const earned = lastAccountData.earned_today ?? 0;
          const cap = lastAccountData.daily_earn_cap ?? 0;

          if (cap && earned >= cap) {
            setStatus(`Auto-mine: daily cap reached (${earned}/${cap}).`);
            break;
          }

          const nowLocal = Math.floor(Date.now() / 1000);
          const serverNow = nowLocal + serverTimeOffset;
          const cdUntil = lastAccountData.cooldown_until || 0;

          if (cdUntil > serverNow) {
            let waitMs = (cdUntil - serverNow) * 1000 + 500;
            setStatus(`Auto-mine waiting for cooldown (${cdUntil - serverNow}s)...`);

            const step = 1000;
            while (waitMs > 0 && autoMineEnabled && accountId) {
              const chunk = Math.min(step, waitMs);
              await new Promise((resolve) => setTimeout(resolve, chunk));
              waitMs -= chunk;
            }
            if (!autoMineEnabled || !accountId) {
              setStatus("Auto-mine stopped.");
              break;
            }
          }
          await earnCredit();
          await new Promise((resolve) => setTimeout(resolve, 500));
        }
      } catch (err) {
        console.error("Auto-mine loop error:", err);
        setStatus("Auto-mine stopped due to an error: " + err);
      } finally {
        autoMineRunning = false;
      }
    }

    // ---- Auto-mine resilience helpers (Safari / background tabs) ----
    // When the tab becomes visible again, resume auto-mine if it was enabled
    // but the loop is no longer running (e.g. after a background error or timer freeze).
    if (!window.__autoMineVisibilityBound) {
      window.__autoMineVisibilityBound = true;
      document.addEventListener("visibilitychange", () => {
        // Only act when the tab becomes visible again
        if (!document.hidden) {
          // autoMineEnabled: user requested auto-mine
          // accountId: we still have a valid account
          // !autoMineRunning: loop is not currently active
          // !miningActive: we are not in the middle of a manual/claim PoW
          if (autoMineEnabled && accountId && !autoMineRunning && !miningActive) {
            setStatus("Tab is active again ‚Äì resuming auto-mine‚Ä¶");
            autoMineLoop();
          }
        }
      });
    }

    // Lightweight watchdog: in case the loop stopped due to an error while
    // auto-mine is still enabled, periodically check and restart it when
    // the tab is in the foreground.
    if (!window.__autoMineWatchdogBound) {
      window.__autoMineWatchdogBound = true;
      setInterval(() => {
        // Do not wake the miner while the tab is backgrounded; Safari
        // heavily throttles timers there anyway.
        if (document.hidden) {
          return;
        }
        if (autoMineEnabled && accountId && !autoMineRunning && !miningActive) {
          setStatus("Watchdog: restarting auto-mine loop‚Ä¶");
          autoMineLoop();
        }
      }, 60000); // check at most once per minute
    }

    async function refreshAccount() {
      if (!accountId) {
        setAccountInfo();
        setCredits("");
        resetHashrateUI();
        lastCooldownUntil = 0;
        updateCooldownCountdown();
        updateVisibility();
        // Hide/clear status-panel address line
        const statusAddrEl = document.getElementById("status-address");
        if (statusAddrEl) {
          statusAddrEl.style.display = "none";
          statusAddrEl.textContent = "";
        }
        const me = document.getElementById("mobile-earned");
        if (me) me.textContent = "Earned today: ‚Äì";
        return;
      }
      try {
        const res = await fetch(`${BASE_URL}/me`, {
          method: "GET",
          headers: {
            "Authorization": "Bearer " + accountId
          }
        });
        if (!res.ok) {
          lastAccountData = null;
          const text = await res.text();
          if (res.status === 401) {
            // Stored private key does not correspond to a valid account on the server.
            accountId = null;
            localStorage.removeItem("account_id");
            currentAddress = null;
            lastCooldownUntil = 0;
            setAccountInfo();
            updateCooldownCountdown();
            setAccountStatus("Stored private key is invalid or account no longer exists. Please signup again or import a valid key.");
            updateVisibility();
          } else {
            setStatus("Failed to load account info: " + text);
          }
          return;
        }
        const data = await res.json();
        lastAccountData = data;
        setAccountInfo();

        const addressHtml = `
          Address: <span class="mono" id="address-text">${data.account_id}</span>
          <button type="button" class="icon-button btn-copy-address" title="Copy address to clipboard">üìã</button>
          <button type="button" class="icon-button btn-show-qr" title="Show address as QR">üî≥</button>
        `;

        // Account section (Account management)
        const addrEl = document.getElementById("address-info");
        if (addrEl) {
          addrEl.innerHTML = addressHtml;
        }

        // Status panel (top)
        const statusAddrEl = document.getElementById("status-address");
        if (statusAddrEl) {
          statusAddrEl.style.display = "";
          statusAddrEl.innerHTML = addressHtml;
        }

        // Wire up all copy buttons (there are two instances: status panel + account section)
        document.querySelectorAll(".btn-copy-address").forEach((btn) => {
          btn.onclick = () => copyAddressToClipboard(data.account_id);
        });

        document.querySelectorAll(".btn-show-qr").forEach((btn) => {
          btn.onclick = () => openQrModal("Address", data.account_id);
        });

        currentAddress = data.account_id;

        // Update mobile sticky topbar text + copy
        const mb = document.getElementById("mobile-balance");
        const me = document.getElementById("mobile-earned");
        const ma = document.getElementById("mobile-address");

        if (mb) mb.textContent = `Balance: ${data.credits} HCC`;
        if (me) me.textContent = `Earned today: ${data.earned_today}/${data.daily_earn_cap}`;
        if (ma) ma.textContent = `Address: ${shortenAccountIdTiny(data.account_id)}`;

        const btnMobileCopy = document.getElementById("btn-mobile-copy");
        if (btnMobileCopy) {
          btnMobileCopy.onclick = () => copyAddressToClipboard(data.account_id);
        }

        const nowLocal = Math.floor(Date.now() / 1000);
        serverTimeOffset = data.server_time - nowLocal;
        lastCooldownUntil = data.cooldown_until;

        setCredits(
          `Balance: ${data.credits} HCC\nEarned today: ${data.earned_today}/${data.daily_earn_cap}`
        );
        updateCooldownCountdown();
        updateVisibility();
      } catch (err) {
        console.error(err);
        setStatus("Error loading account info: " + err);
      }
    }

    // ---------------------------
// DEX UI helpers
// ---------------------------

function getRequiredConfs(currency) {
  const sym = String(currency || "").toUpperCase();
  const c = faucetConfig && faucetConfig.coins && faucetConfig.coins[sym];

  // Preferred field (per coin): cfg.coins[SYM].dex_min_confs
  const perCoin = c && (c.dex_min_confs ?? c.min_confs ?? c.min_confirmations);

  // Optional global fallback if backend ever exposes it top-level
  const globalMc = faucetConfig && (faucetConfig.dex_min_confs ?? faucetConfig.min_confs ?? faucetConfig.min_confirmations);

  const val = (typeof perCoin === "number" ? perCoin : (typeof globalMc === "number" ? globalMc : 1));
  return Math.max(0, Math.floor(val));
}

function shortTxid(s) {
  if (!s) return "-";
  const str = String(s);
  if (str.length <= 16) return str;
  return str.slice(0, 10) + "‚Ä¶" + str.slice(-6);
}

function myAccountAddress() {
  return (lastAccountData && lastAccountData.account_id) || currentAddress || null;
}

// Persistently hide settled trades (client-side only)
const DEX_HIDDEN_TRADES_KEY = "dex_hidden_trade_ids";

function loadHiddenTradeIds() {
  try {
    const raw = localStorage.getItem(DEX_HIDDEN_TRADES_KEY);
    if (!raw) return new Set();
    const arr = JSON.parse(raw);
    if (!Array.isArray(arr)) return new Set();
    return new Set(arr.map((x) => Number(x)).filter((n) => Number.isFinite(n)));
  } catch (e) {
    return new Set();
  }
}

function saveHiddenTradeIds(setObj) {
  try {
    const arr = Array.from(setObj.values());
    localStorage.setItem(DEX_HIDDEN_TRADES_KEY, JSON.stringify(arr));
  } catch (e) {
    // ignore
  }
}

function isTradeHidden(tradeId) {
  const id = Number(tradeId);
  if (!Number.isFinite(id)) return false;
  return loadHiddenTradeIds().has(id);
}

function hideTrade(tradeId) {
  const id = Number(tradeId);
  if (!Number.isFinite(id)) return;
  const s = loadHiddenTradeIds();
  s.add(id);
  saveHiddenTradeIds(s);
}


function formatCoinAmount(amountCoin) {
  const n = Number(amountCoin);
  if (!Number.isFinite(n)) return "-";
  let s = n.toFixed(8);
  s = s.replace(/\.0+$/, "");
  s = s.replace(/(\.[0-9]*?)0+$/, "$1");
  return s;
}

function formatDurationHMS(totalSeconds) {
  const sec = Math.max(0, Math.floor(Number(totalSeconds) || 0));
  const h = Math.floor(sec / 3600);
  const m = Math.floor((sec % 3600) / 60);
  const s = sec % 60;
  if (h > 0) return `${h}h ${m}m ${s}s`;
  return `${m}m ${s}s`;
}

function coinFromSats(sats) {
  const n = Number(sats);
  if (!Number.isFinite(n)) return NaN;
  return n / 100000000;
}

function satsFromCoin(amountCoin) {
  const n = Number(amountCoin);
  if (!Number.isFinite(n)) return NaN;
  return Math.round(n * 100000000);
}

function populateDexCurrencies() {
  const sel = document.getElementById("dex-currency");
  if (!sel) return;

  let syms = [];

  // Prefer explicit per-coin flag from /config
  if (faucetConfig && faucetConfig.coins && typeof faucetConfig.coins === "object") {
    syms = Object.keys(faucetConfig.coins).filter((sym) => {
      const c = faucetConfig.coins[sym];
      return c && c.dex_enabled === true;
    });
  }

  // Fallback (keep UI usable if config is missing or no coin is enabled yet)
  if (syms.length === 0) syms = ["VECO"];

  sel.innerHTML = "";
  syms.sort().forEach((sym) => {
    const opt = document.createElement("option");
    opt.value = sym;
    opt.textContent = sym;
    sel.appendChild(opt);
  });
}

function setDexStatus(msg) {
  const el = document.getElementById("dex-status");
  if (!el) return;
  el.textContent = msg;
  console.log(msg);
}

function updateDexPaytoVisibility() {
  const sideEl = document.getElementById("dex-side");
  const wrap = document.getElementById("dex-payto-wrap");
  const payToEl = document.getElementById("dex-payto");
  if (!sideEl || !wrap) return;

  const side = (sideEl.value || "").trim();
  const show = (side === "SELL_CREDITS");
  wrap.style.display = show ? "" : "none";

  if (!show && payToEl) payToEl.value = "";
}

async function dexFetchJson(path, opts = {}) {
  const url = `${BASE_URL}${path}`;
  const headers = Object.assign({}, opts.headers || {});
  if (accountId) headers["Authorization"] = "Bearer " + accountId;

  const res = await fetch(url, Object.assign({}, opts, { headers }));
  if (!res.ok) {
    let msg;
    try {
      const j = await res.json();
      msg = j.detail || JSON.stringify(j);
    } catch (e) {
      msg = await res.text();
    }
    throw new Error(`${res.status} ${res.statusText}: ${msg}`);
  }
  return await res.json();
}

async function refreshDex() {
  if (!accountId) return;
  await Promise.allSettled([refreshDexOpenOrders(), refreshDexMyTrades()]);
}

async function refreshDexOpenOrders() {
  const el = document.getElementById("dex-open-orders");
  if (!el) return;
  try {
    const orders = await dexFetchJson(`/dex/orders?status=OPEN&limit=20`, { method: "GET" });
    renderDexOpenOrders(orders);
  } catch (e) {
    console.error(e);
    el.textContent = "Open orders unavailable: " + e;
  }
}

function renderDexOpenOrders(orders) {
  const el = document.getElementById("dex-open-orders");
  if (!el) return;

  if (!orders || orders.length === 0) {
    el.textContent = "No open orders.";
    return;
  }

  const sorted = orders.slice().sort((a, b) => (b.created_at || 0) - (a.created_at || 0));
  el.innerHTML = "";

  sorted.forEach((o) => {
    const row = document.createElement("div");
    row.className = "dex-row";

    const mine = o.maker_account_id && myAccountAddress() && (o.maker_account_id === myAccountAddress());
    const side = o.side || "-";
    const cur = o.currency || "-";
    const amt = Number(o.credits_amount ?? 0);
    const ppcSat = Number(o.price_sat_per_credit ?? 0);
    const ppcCoin = coinFromSats(ppcSat);
    const totalCoin = (Number.isFinite(amt) && Number.isFinite(ppcCoin)) ? (amt * ppcCoin) : NaN;

    const verb = (side === "BUY_CREDITS") ? "buy" : (side === "SELL_CREDITS") ? "sell" : side;

    const info = document.createElement("div");
    info.innerHTML =
      `<strong>#${o.order_id}</strong><br>` +
      `<span style="opacity:0.8;">maker=${shortenAccountId(o.maker_account_id)} wants to </span>` +
      `${verb} ${formatCoinAmount(amt)} HCC for <strong>${formatCoinAmount(totalCoin)} ${cur}</strong> ` +
      `<span style="opacity:0.85;">(${formatCoinAmount(ppcCoin)} ${cur}/credit)</span>`;

    const actions = document.createElement("div");
    actions.className = "dex-actions";

    if (mine) {
      const btn = document.createElement("button");
      btn.textContent = "Cancel";
      btn.type = "button";
      btn.addEventListener("click", () => cancelDexOrder(o.order_id));
      actions.appendChild(btn);
    } else {
      const btn = document.createElement("button");
      btn.textContent = "Take";
      btn.type = "button";
      btn.addEventListener("click", () => takeDexOrder(o));
      actions.appendChild(btn);
    }

    row.appendChild(info);
    row.appendChild(actions);
    el.appendChild(row);
  });
}

async function refreshDexMyTrades() {
  const el = document.getElementById("dex-my-trades");
  if (!el) return;
  try {
    const states = ["WAIT_PAYMENT", "CONFIRMED", "SETTLED"];
    const results = await Promise.allSettled(
      states.map((st) => dexFetchJson(`/dex/trades/mine?state=${encodeURIComponent(st)}`, { method: "GET" }))
    );

    const all = [];
    for (const r of results) {
      if (r.status === "fulfilled" && Array.isArray(r.value)) all.push(...r.value);
    }

    const byId = new Map();
    all.forEach((t) => {
      if (t && (t.trade_id || t.trade_id === 0)) byId.set(t.trade_id, t);
    });

    const trades = Array.from(byId.values())
      .sort((a, b) => (b.created_at || 0) - (a.created_at || 0))
      .filter((t) => !isTradeHidden(t.trade_id))
      .slice(0, 10);

    renderDexMyTrades(trades);
  } catch (e) {
    console.error(e);
    el.textContent = "My trades unavailable: " + e;
  }
}

function renderDexMyTrades(trades) {
  const el = document.getElementById("dex-my-trades");
  if (!el) return;

  if (!trades || trades.length === 0) {
    el.textContent = "No trades yet.";
    return;
  }

  el.innerHTML = "";

  trades.forEach((t) => {
    const row = document.createElement("div");
    row.className = "dex-row";

    // Normalize fields for robust comparison and display
    const side = String(t.side || "-").trim().toUpperCase();
    const cur = String(t.currency || "-").trim().toUpperCase();
    const amt = Number(t.credits_amount ?? 0);
    const expSat = Number(t.expected_sats ?? NaN);
    const expCoin = coinFromSats(expSat);
    const state = String(t.state || "-").trim().toUpperCase();

    // Who am I in this trade?
    const me = myAccountAddress();
    const makerId = String(t.maker_account_id ?? t.maker ?? t.maker_id ?? "").trim();
    const takerId = String(t.taker_account_id ?? t.taker ?? t.taker_id ?? "").trim();

    const isMaker = !!(me && makerId && makerId === me);
    // Some endpoints may omit taker id; if maker id is present and it's not me, assume I'm the taker.
    const isTaker = !!(
      (me && takerId && takerId === me) ||
      (me && makerId && makerId !== me)
    );

    // Perspective-adjusted verb (invert for taker)
    const verb = (side === "BUY_CREDITS")
      ? (isMaker ? "Buy" : "Sell")
      : (side === "SELL_CREDITS")
        ? (isMaker ? "Sell" : "Buy")
        : side;

    // Determine who must pay the on-chain coins in WAIT_PAYMENT.
    // pay_to_address is always the coin recipient address for the on-chain payment.
    let payerIsMe = false;
    let payeeIsMe = false;
    if (side === "SELL_CREDITS") {
      // Maker sells credits, taker must pay coins to maker.
      payerIsMe = isTaker;
      payeeIsMe = isMaker;
    } else if (side === "BUY_CREDITS") {
      // Maker buys credits, maker must pay coins to taker.
      payerIsMe = isMaker;
      payeeIsMe = isTaker;
    }

    const confsRaw = (typeof t.confs === "number" ? t.confs : 0);
    const req = getRequiredConfs(cur);

    // UI fix: if already settled, treat confirmations as complete.
    const nowLocal = Math.floor(Date.now() / 1000);
    const serverNow = nowLocal + serverTimeOffset;
    const expiresAt = (typeof t.expires_at === "number" ? t.expires_at : Number(t.expires_at || 0));
    const isExpiredByTime = (state === "WAIT_PAYMENT" && expiresAt > 0 && (expiresAt - serverNow) <= 0);

    // Also honor explicit backend failure states if they exist.
    const rawState = state;
    const failedStates = new Set(["FAILED", "EXPIRED", "CANCELLED", "CANCELED", "REFUSED", "REJECTED"]);
    const isFailedState = failedStates.has(rawState);

    const stateDisplay = (isExpiredByTime || isFailedState) ? "FAILED" : rawState;
    const failReason = isExpiredByTime || rawState === "EXPIRED" ? "trade expired" : "";

    const confsShown = (stateDisplay === "SETTLED") ? req : confsRaw;
    const remaining = Math.max(0, req - confsShown);

    // Only show expiry while *still* waiting and not already expired.
    let extra = "";
    if (stateDisplay === "WAIT_PAYMENT" && expiresAt > 0) {
      const left = Math.max(0, (expiresAt - serverNow));
      extra = `, expires in ${formatDurationHMS(left)}`;
    }

    const info = document.createElement("div");

    const expCoinText = formatCoinAmount(expCoin);

    let instructionLine = "";
    if (stateDisplay === "FAILED") {
      instructionLine =
        `<div style="margin-top:6px; padding:6px 8px; border:1px solid rgba(255,255,255,0.15); border-radius:8px; background:rgba(0,0,0,0.18);">` +
        `‚ùå <strong>Failed</strong>${failReason ? ` ‚Äî ${failReason}` : ""}` +
        `</div>`;
    } else if (stateDisplay === "WAIT_PAYMENT") {
      const addr = (t.pay_to_address || "").trim();

      if (!addr) {
        instructionLine =
          `<div style="margin-top:6px; opacity:0.9;">Waiting for payment details‚Ä¶</div>`;
      } else if (payerIsMe) {
        // I must send the on-chain coins to the recipient address.
        instructionLine =
          `<div style="margin-top:6px; padding:6px 8px; border:1px solid rgba(255,255,255,0.15); border-radius:8px; background:rgba(0,0,0,0.18);">` +
          `<strong>Payment required:</strong> send <strong>${expCoinText} ${cur}</strong> to<br>` +
          `<span style="word-break:break-all;">${addr}</span>` +
          `</div>`;
      } else {
        // Counterparty must pay; I'm waiting.
        const who = payeeIsMe ? "to your address" : "to";
        instructionLine =
          `<div style="margin-top:6px; padding:6px 8px; border:1px solid rgba(255,255,255,0.15); border-radius:8px; background:rgba(0,0,0,0.18);">` +
          `‚è≥ <strong>Waiting for payment</strong> ${who}<br>` +
          `<span style="word-break:break-all;">${addr}</span>` +
          `</div>`;
      }
    } else if (stateDisplay === "CONFIRMED") {
      const txFull = String(t.txid || "").trim();
      if (txFull) {
        instructionLine =
          `<div style="margin-top:6px; padding:6px 8px; border:1px solid rgba(255,255,255,0.15); border-radius:8px; background:rgba(0,0,0,0.18);">` +
          `‚è≥ <strong>Payment detected</strong>. Waiting for <strong>${remaining}</strong> more confirmation(s).<br>` +
          `<span style="opacity:0.9;">txid:</span> <span style="word-break:break-all;">${txFull}</span>` +
          `</div>`;
      } else {
        instructionLine =
          `<div style="margin-top:6px; opacity:0.9;">‚è≥ Payment detected. Waiting for <strong>${remaining}</strong> more confirmation(s)‚Ä¶</div>`;
      }
    } else if (stateDisplay === "SETTLED") {
      const txFull = String(t.txid || "").trim();
      if (txFull) {
        instructionLine =
          `<div style="margin-top:6px; padding:6px 8px; border:1px solid rgba(255,255,255,0.15); border-radius:8px; background:rgba(0,0,0,0.18);">` +
          `‚úÖ <strong>Settled</strong><br>` +
          `<span style="opacity:0.9;">txid:</span> <span style="word-break:break-all;">${txFull}</span>` +
          `</div>`;
      } else {
        instructionLine =
          `<div style="margin-top:6px; opacity:0.9;">‚úÖ Settled</div>`;
      }
    }

    const metaLine = (stateDisplay === "FAILED")
      ? `state=FAILED${failReason ? ` - ${failReason}` : ""}`
      : `state=${stateDisplay} ¬∑ confs=${confsShown}/${req}${extra}`;

    info.innerHTML =
      `<strong>#${t.trade_id}</strong> (order #${t.order_id}) ${verb} ${formatCoinAmount(amt)} HCC for <strong>${expCoinText} ${cur}</strong><br>` +
      `<span style="opacity:0.85;">${metaLine}</span>` +
      instructionLine;

    row.appendChild(info);

    // Only show an action button for settled trades (client-side hide)
    if (stateDisplay === "SETTLED") {
      const actions = document.createElement("div");
      actions.className = "dex-actions";

      const hideBtn = document.createElement("button");
      hideBtn.type = "button";
      hideBtn.textContent = "‚úñ";
      hideBtn.title = "Hide this settled trade";
      hideBtn.addEventListener("click", async () => {
        hideTrade(t.trade_id);
        setDexStatus(`Hidden settled trade #${t.trade_id}.`);
        await refreshDexMyTrades();
      });

      actions.appendChild(hideBtn);
      row.appendChild(actions);
    }
    el.appendChild(row);
  });
}

async function placeDexOrder() {
  if (!accountId) {
    setDexStatus("No private key loaded ‚Äì please signup or import one first.");
    return;
  }

  const side = (document.getElementById("dex-side")?.value || "").trim();
  const currency = (document.getElementById("dex-currency")?.value || "").trim();
  const credits = parseInt(document.getElementById("dex-credits")?.value, 10);
  const priceCoinPerCredit = parseFloat(document.getElementById("dex-price")?.value);
  const payTo = (document.getElementById("dex-payto")?.value || "").trim();

  if (!side || !currency) return setDexStatus("Please select side and currency.");
  if (!Number.isFinite(credits) || credits <= 0) return setDexStatus("Enter a valid HCC amount.");
  if (!Number.isFinite(priceCoinPerCredit) || priceCoinPerCredit <= 0) return setDexStatus("Enter a valid price (coin/credit).");
  if (side === "SELL_CREDITS" && !payTo) return setDexStatus("SELL_CREDITS needs pay_to_address.");

  const priceSatPerCredit = satsFromCoin(priceCoinPerCredit);
  if (!Number.isFinite(priceSatPerCredit) || priceSatPerCredit <= 0) return setDexStatus("Price conversion failed.");

  const payload = {
    side,
    currency,
    credits_amount: credits,
    price_sat_per_credit: priceSatPerCredit
  };

  if (side === "SELL_CREDITS") {
    payload.pay_to_address = payTo;
  }

  try {
    setDexStatus("Placing order‚Ä¶");
    const created = await dexFetchJson(`/dex/orders`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload)
    });
    setDexStatus(`Order placed: #${created.order_id} (${created.status})`);
    await refreshAccount();
    await refreshDex();
  } catch (e) {
    console.error(e);
    setDexStatus("Place order failed: " + e);
  }
}

async function takeDexOrder(order) {
  try {
    const orderId = (order && (order.order_id ?? order.id)) ? Number(order.order_id ?? order.id) : Number(order);
    if (!Number.isFinite(orderId)) {
      setDexStatus("Take failed: invalid order id");
      return;
    }

    const side = String(order && order.side ? order.side : "").trim().toUpperCase();
    const cur = String(order && order.currency ? order.currency : "").trim().toUpperCase();

    const payload = {};

    // BUY_CREDITS: Maker will pay coins to the taker. We must provide taker's pay-to address.
    if (side === "BUY_CREDITS") {
      const key = `dex_taker_payto_${cur || "COIN"}`;
      const last = (localStorage.getItem(key) || "").trim();
      const addr = (window.prompt(
        `This is a BUY order. Enter your ${cur || "coin"} address to receive payment:`,
        last
      ) || "").trim();

      if (!addr) {
        setDexStatus("Take canceled (missing taker payment address). ");
        return;
      }

      payload.taker_pay_to_address = addr;
      localStorage.setItem(key, addr);
    }

    setDexStatus(`Taking order #${orderId}‚Ä¶`);

    const trade = await dexFetchJson(`/dex/orders/${orderId}/take`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload)
    });

    setDexStatus(`Trade created: #${trade.trade_id} (state=${trade.state})`);
    await refreshAccount();
    await refreshDex();
  } catch (e) {
    console.error(e);
    setDexStatus("Take failed: " + e);
  }
}

async function cancelDexOrder(orderId) {
  try {
    setDexStatus(`Canceling order #${orderId}‚Ä¶`);
    const resp = await dexFetchJson(`/dex/orders/${orderId}/cancel`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({})
    });
    setDexStatus(resp.detail ? `Canceled: ${resp.detail}` : `Order #${orderId} canceled.`);
    await refreshAccount();
    await refreshDex();
  } catch (e) {
    console.error(e);
    setDexStatus("Cancel failed: " + e);
  }
}

    document.getElementById("btn-signup").addEventListener("click", () => {
      signup().catch(err => {
        console.error(err);
        setStatus("Error: " + err);
      });
    });

    const stopBtn1 = document.getElementById("btn-stop-mining");
    if (stopBtn1) {
      stopBtn1.addEventListener("click", () => stopMining("Mining stopped."));
    }

    const stopBtn2 = document.getElementById("btn-stop-mining-signup");
    if (stopBtn2) {
      stopBtn2.addEventListener("click", () => stopMining("Mining stopped."));
    }

    const retryBtn = document.getElementById("btn-signup-retry");
    if (retryBtn) {
      retryBtn.addEventListener("click", () => {
        const pending = loadPendingSignup();
        if (!pending) {
          setSignupRetryUI(false, "No pending signup payload found.");
          return;
        }
        submitSignupPow(pending).catch((err) => {
          console.error(err);
          setStatus("Error: " + err);
        });
      });
    }

    document.getElementById("btn-earn").addEventListener("click", () => {
      earnCredit().catch(err => {
        console.error(err);
        setStatus("Error: " + err);
      });
    });

    const autoMineCheckbox = document.getElementById("auto-mine-checkbox");
    if (autoMineCheckbox) {
      autoMineCheckbox.addEventListener("change", (ev) => {
        autoMineEnabled = ev.target.checked;
        if (autoMineEnabled) {
          if (!accountId) {
            setStatus("No account ‚Äì please signup or import an account before enabling auto-mine.");
            autoMineCheckbox.checked = false;
            autoMineEnabled = false;
            return;
          }
          if (!autoMineRunning) {
            autoMineLoop().catch((err) => {
              console.error(err);
              setStatus("Auto-mine error: " + err);
            });
          }
        } else {
          setStatus("Auto-mine stopped.");
        }
      });
    }

    document.getElementById("btn-import").addEventListener("click", () => {
      const input = document.getElementById("import-account");
      const value = (input.value || "").trim();
      if (!value) {
        setAccountStatus("Please enter a private key to import.");
        return;
      }
      accountId = value;
      localStorage.setItem("account_id", accountId);
      updateVisibility();
      setAccountStatus("Private key imported.");
      refreshRedeemLog();
      refreshAccount().catch(err => {
        console.error(err);
        setAccountStatus("Error while refreshing account: " + err);
      });
    });

    document.getElementById("btn-export").addEventListener("click", () => {
      if (!accountId) {
        setAccountStatus("No private key in this browser to export.");
        return;
      }
      const input = document.getElementById("import-account");
      if (input) {
        input.value = accountId;
      }
      setAccountStatus("Private key copied into the input field. Please back it up safely (e.g. password manager or paper).");
    });

    document.getElementById("btn-export-file").addEventListener("click", () => {
      if (!accountId) {
        setAccountStatus("No private key in this browser to export.");
        return;
      }
      const data = {
        private_key: accountId,
        address: currentAddress || null
      };
      const blob = new Blob([JSON.stringify(data, null, 2)], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = currentAddress
        ? `pow_faucet_key_${currentAddress}.json`
        : "pow_faucet_key.json";
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      setAccountStatus("Key file downloaded. Please store it safely (e.g. password manager, encrypted storage, or paper).");
    });

    document.getElementById("btn-clear").addEventListener("click", () => {
      // Safety confirmation: clearing the local private key cannot be undone.
      // If the user has not backed up the key, all credits tied to it are effectively lost.
      const ok = window.confirm(
        "Delete the locally stored private key from this browser?\n\n" +
        "This action cannot be undone. If you have NOT exported/backed up your private key, you may permanently lose access to your Credits.\n\n" +
        "Click OK to delete, or Cancel to keep it."
      );

      if (!ok) {
        setAccountStatus("Clear canceled. Local private key was NOT deleted.");
        return;
      }

      accountId = null;
      localStorage.removeItem("account_id");
      currentAddress = null;
      lastCooldownUntil = 0;

      const importInput = document.getElementById("import-account");
      if (importInput) {
        importInput.value = "";
      }
      const addrEl = document.getElementById("address-info");
      if (addrEl) {
        addrEl.textContent = "";
      }
      const statusAddrEl = document.getElementById("status-address");
      if (statusAddrEl) {
        statusAddrEl.style.display = "none";
        statusAddrEl.textContent = "";
      }

      updateVisibility();
      setAccountStatus("Local private key cleared from this browser.");
      refreshRedeemLog();
      refreshAccount().catch(err => {
        console.error(err);
        setAccountStatus("Error while refreshing account: " + err);
      });
    });

    document.getElementById("btn-send").addEventListener("click", () => {
      if (!accountId) {
        setSendStatus("No private key loaded ‚Äì please signup or import a private key before sending.");
        return;
      }

      const toInput = document.getElementById("send-to-address");
      const amtInput = document.getElementById("send-amount");
      const toAddress = (toInput.value || "").trim();
      const amount = parseInt(amtInput.value, 10);

      if (!toAddress) {
        setSendStatus("Please enter a recipient address.");
        return;
      }
      if (!Number.isFinite(amount) || amount <= 0) {
        setSendStatus("Please enter a valid positive amount.");
        return;
      }

      fetch(`${BASE_URL}/transfer`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": "Bearer " + accountId
        },
        body: JSON.stringify({ to_address: toAddress, amount: amount })
      })
        .then(async (res) => {
          if (!res.ok) {
            const text = await res.text();
            setSendStatus("Transfer failed: " + text);
            return;
          }
          const data = await res.json();
          setSendStatus("Transfer ok. Your new balance: " + data.from_credits + " HCC.");
          refreshAccount().catch(err => {
            console.error(err);
            setSendStatus("Error while refreshing account after transfer: " + err);
          });
        })
        .catch(err => {
          console.error(err);
          setSendStatus("Error while sending transfer: " + err);
        });
    });

    const redeemBtn = document.getElementById("btn-redeem");
    if (redeemBtn) {
      redeemBtn.addEventListener("click", () => {
        if (!accountId) {
          setRedeemStatus("No private key loaded ‚Äì please signup or import a private key before requesting a redeem.");
          return;
        }

        const addrInput = document.getElementById("redeem-address");
        const currInput = document.getElementById("redeem-currency");
        const tipAddress = (addrInput.value || "").trim();
        const currency = (currInput.value || "").trim();

        if (!tipAddress) {
          setRedeemStatus("Please enter a tip address.");
          return;
        }

        fetch(`${BASE_URL}/redeem_request`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Authorization": "Bearer " + accountId
          },
          body: JSON.stringify({
            tip_address: tipAddress,
            currency: currency || null
          })
        })
          .then(async (res) => {
            if (!res.ok) {
              let msg;
              try {
                const errData = await res.json();
                msg = errData.detail || JSON.stringify(errData);
              } catch (e) {
                msg = await res.text();
              }
              setRedeemStatus("Redeem request failed: " + msg);
              return;
            }
            const data = await res.json();

            // Append to local redeem log (fields are expected from the backend audit enqueue)
            // Falls back to currentAddress / client time if not present.
            refreshRedeemLog();

            let extra = "";
            if ((data.tip_amount === 0 || data.tip_amount) && data.txid && data.currency) {
              extra = ` Tip sent: ${data.tip_amount} ${data.currency}, txid: ${data.txid}.`;
            }

            let stateInfo = "";
            if (data.state) {
              stateInfo += ` State: ${data.state}.`;
            }
            if (data.note) {
              stateInfo += ` ${data.note}`;
            }

            setRedeemStatus(
              data.message +
              extra +
              stateInfo +
              " HCC left: " + data.credits_left +
              ". Minimum required: " + data.min_credits + "."
            );

            refreshAccount().catch(err => {
              console.error(err);
              setRedeemStatus("Error while refreshing account after redeem request: " + err);
            });
          })
          .catch(err => {
            console.error(err);
            setRedeemStatus("Error while sending redeem request: " + err);
          });
      });
    }

    // Redeem log clear button
    // Redeem log refresh button
    const clearRedeemLogBtn = document.getElementById("btn-clear-redeem-log");
    if (clearRedeemLogBtn) {
      clearRedeemLogBtn.addEventListener("click", () => {
        refreshRedeemLog();
        setRedeemStatus("Redeem log refreshed.");
      });
    }

    // DEX UI events
    const dexSideEl = document.getElementById("dex-side");
    if (dexSideEl) {
      dexSideEl.addEventListener("change", updateDexPaytoVisibility);
      updateDexPaytoVisibility();
    }

    const dexPlaceBtn = document.getElementById("btn-dex-place");
    if (dexPlaceBtn) {
      dexPlaceBtn.addEventListener("click", () => placeDexOrder());
    }

    const dexRefreshBtn = document.getElementById("btn-dex-refresh");
    if (dexRefreshBtn) {
      dexRefreshBtn.addEventListener("click", () => refreshDex());
    }

    // Initial UI state
    setupToggleNotes();
    setupMobileNav();
    window.addEventListener("resize", () => updateVisibility());

    updateVisibility();
    refreshRedeemLog();

    // Initialize worker-threads input based on hardware concurrency
    (function initPowThreadsInput() {
      const input = document.getElementById("pow-threads");
      const hint = document.getElementById("pow-threads-hint");
      if (!input) return;
      const hc = navigator.hardwareConcurrency || 0;
      if (hc > 0) {
        input.max = String(hc);
        const defaultWorkers = Math.min(4, hc);
        input.value = String(defaultWorkers);
        if (hint) {
          hint.textContent = `(up to ${hc} threads)`;
        }
      } else {
        input.value = "1";
        if (hint) {
          hint.textContent = "";
        }
      }
    })();

    updateVisibility();
    refreshRedeemLog();

    // If we have a pending signup submit and no account yet, show retry UI.
    if (!accountId) {
      const pending = loadPendingSignup();
      if (pending) {
        setSignupRetryUI(true, "Pending signup PoW found. Click 'Retry signup submit' to finish account creation.");
      }
    }

    if (accountId) {
      refreshAccount().then(() => refreshDex()).catch(() => refreshDex());
    }

    // Polling: keep /me traffic low. DEX status can refresh more often than account state.
    // - /me (account + credits + cooldown) every 20s
    // - DEX (orders/trades/confs) every 10s
    // Also pause polling while the tab is hidden.

    const ACCOUNT_POLL_MS = 5000;
    const DEX_POLL_MS = 10000;

    function isTabVisible() {
      return document.visibilityState === "visible";
    }

    // Account poll (/me)
    setInterval(() => {
      if (!accountId) return;
      if (!isTabVisible()) return;
      refreshAccount().catch((e) => console.error("Account refresh error:", e));
    }, ACCOUNT_POLL_MS);

    // DEX poll (no need to hit /me every time)
    setInterval(() => {
      if (!accountId) return;
      if (!isTabVisible()) return;
      refreshDex().catch((e) => console.error("DEX refresh error:", e));
    }, DEX_POLL_MS);

    // When the user returns to the tab, refresh immediately.
    document.addEventListener("visibilitychange", () => {
      if (!accountId) return;
      if (!isTabVisible()) return;
      refreshAccount().then(() => refreshDex()).catch(() => refreshDex());
    });

    // Load server config (signup_bits, min_redeem_credits, etc.) and then refresh account
    loadConfig().then(() => {
      refreshAccount();
    }).catch(err => {
      console.error("Error during initial config load:", err);
      refreshAccount();
    });
    // PWA: register service worker (safe no-op on unsupported browsers)
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('./sw.js', { scope: './' }).catch((err) => {
          console.error('Service worker registration failed:', err);
        });
      });
    }
  </script>

  <hr>
  </body>
  </html>
